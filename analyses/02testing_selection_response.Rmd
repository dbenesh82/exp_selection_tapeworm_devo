---
title: "Testing response to selection"
output: 
  github_document:
    toc: true
    df_print: kable
---

I experimentally selected tapeworms (*S. solidus*) for faster and slower development in their intermediate host. In this notebook, I test whether there was a response to selection, as well as whether there were correlated responses in other traits.

```{r setup, include=FALSE}
library(tidyverse)
library(MCMCglmm)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
options(stringsAsFactors = FALSE)
theme_set(theme_bw())
theme_update(panel.grid.minor = element_blank())
```

```{r}
dat <- read.csv(file="../data/sel_exp_data.csv", header = TRUE)
```
```{r}
#Make some centered variables...
dat <- dat%>%
  mutate(cop_length_cen = scale(cop_length_mm, scale = FALSE),
         fish_initial_tl_cen = scale(fish_initial_tl, scale = FALSE),
         fish_initial_bm_cen = scale(fish_initial_bm_g, scale = FALSE),
         age_diss_cen = scale(age_dissection, scale = FALSE),
         fish_sex_cen = fish_sex - 0.5,
         proc_size2 = procercoid_size/1000, # avoid numerical problems, mm2
         proc_size_std = scale(procercoid_size, scale = TRUE),
         worm_bm_mg_std = scale(worm_bm_mg, scale = TRUE),
         tank_id = if_else(tank_id %in% c("_", "0_","1_","2_", "3_", "4_"), NA_character_, tank_id),
         gen_line = if_else(line !="",paste(gen, line, sep = "_"), NA_character_))%>%
  mutate(gen_line = factor(gen_line, levels = c("0_base", "1_control", "1_fast", "1_slow",
                                                "2_control", "2_fast", "2_slow", 
                                                "3_control", "3_fast", "3_slow",
                                                "4_control", "4_fast", "4_slow")))
```

```{r}
# full pedigree and relatedness matrix
ped <- select(dat, id, dam, sire)%>%
  mutate_all(as.factor)

ib <- inverseA(ped)$inbreeding

dat <- left_join(
  dat%>%mutate(across(id:sire, as.factor)),
  ped%>%mutate(ib = ib)%>%select(id, ib)
)
```
```{r}
# nice data for dryad that include inbreeding coef
write.csv(
  dat%>%select(
    id, dam, sire, inbreeding_coef = ib, gen, parental_match = maternal_match,
    worm_full_sib_fam_id, worm_maternal_id, selection_line = line, cop_id, cop_block,
    cop_inf, cop_checked_dpe, cop_stage_checking, cerc_ordinal, cerc_bi, 
    cop_dead_13dpe, failed_devo_13dpe, failed_devo_bi, cop_length_mm, procercoid_size,
    cop_remarks, used_fish_inf, fish_id, fish_exp_on_cop_dpe, fish_initial_tl, fish_initial_sl,
    fish_initial_bm_g, tank_id, fish_surv, age_fish_dissection = age_dissection, fish_final_tl, 
    fish_final_sl, fish_final_bm_g, fish_final_bm_g_noworm, fish_liver_mg, fish_sex, fish_inf = schisto_inf,
    worm_bm_mg, fish_and_copepod_matched, used_breeding, fish_worm_remark, eggs_clutch_id, eggs_maternal_id,
    breeding_block, diff_mg_to_breeding_partner, breeding_partner_size_mg, 
    eggnum_d2_6_indiv, eggsize_d2_6_indiv, clutchmass_d2_6_indiv, 
    eggs_checked_for_hatching = eggs_checked, eggs_hatched = hatched, hatching_rate_d2_6
    ),
  file = "../data/sel_exp_data_clean.csv", row.names = F)
```

Let's start by looking at the trait we selected upon: cercomere presence 9 day post infection.

# Focal selection response: larval development

Infected copepods were checked under a microscope 9 dpi. Worms were scored as either having or not having a cercomere. The cercomere is a sign of infectivity. Parasite development may be affected by several things besides the imposed selection. For instance, developmental rate may vary between infection rounds, and within rounds depending on copepod stage. Let's look at some of these predictors.

## Response to selection

To handle the many copepods, the experiment was broken in several rounds per generation. Here are the copepod blocks; the first number in the name is the generation, the second is the round. 

```{r}
dx <- dat%>%
  filter(cop_block != "_NA")%>%
  group_by(cop_block)%>%
  summarise(n = n())
dx
```

The experiment involved 22 rounds of copepod infections. The number of copepods per round ranged from `r `min(dx$n)` to `r max(dx$n)`. Usually, copepods were checked for infection 2 or 3 days post exposure.

```{r}
rm(dx)
table(dat$cop_checked_dpe)
```

When the copepods were checked, we recorded the stage. Here is the table of stages. Some copepods lack a stage.

```{r}
table(dat$cop_stage_checking)
```

These are almost all copepods that died before infection was checked, though a few (25) had infection recorded.

```{r}
with(dat, table(cop_stage_checking, cop_inf, useNA = 'always'))
```

Looking at these, we see they correspond to one plate of uninfected copepods, in which stages were probably accidentally not recorded. Also, there is one copepod from generation 3, in which 2 cops were present in the well. 

```{r}
dat%>%
  filter(cop_stage_checking=="", !is.na(cop_inf))%>%
  select(gen, cop_id, cop_checked_dpe, cop_inf, cop_dead_13dpe, cerc_bi, cop_remarks)
```

We'll exclude all the cases in which the copepod stage was not recorded.

```{r}
dat_cerc <- dat%>%
  filter(cop_stage_checking != "", !is.na(cerc_bi))
```

Now, 'stage' is available for every copepod for which we recorded cercomere presence.

```{r}
with(dat_cerc, table(cop_stage_checking, cerc_bi))
```

Here's the number of copepods for which cercomere presence was recorded:

```{r}
sum(!is.na(dat$cerc_bi))
```

We tried to avoid inbreeding, but sometimes we found that, after the fact, some of the parasites bred were related. For instance, the small peak at 0.25 is breeding between full-sibs. But most parasites are fully outbred.

```{r}
sf_ib_x <- ggplot(dat%>%filter(cop_stage_checking != ""),
       aes(ib)) +
  geom_histogram(bins = 100) +
  labs(y = "Count", x = "Inbreeding coefficient")
sf_ib_x
```

Since we are using a finite population, we would expect inbreeding to creep up from one generation to the next. Indeed, it does. Thus, we should account for inbreeding in our models.

```{r}
ggplot(dat%>%filter(cop_stage_checking != ""),
       aes(x = factor(gen), y = ib)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(alpha = 0.05, height = 0.02) +
  labs(x = "Generation", y = "Inbreeding coefficient")
```
Inbreeding might be slightly more common in the selection lines.

```{r}
sf_ib_y <- ggplot(dat%>%filter(cop_stage_checking != "", line != "base"),
       aes(ib)) +
  geom_histogram(aes(y = ..density..), 
              fill = "white",
              color = "black",
               bins = 50) +
  geom_density(aes(color = line)) +
  labs(y = "Density", x = "Inbreeding coefficient") +
  scale_color_manual(values = c("black", "red", "blue")) +
  facet_wrap(~line)
sf_ib_y
```

Let's start to fit models. We'll use the following approach for this trait, as well as the other traits. First, we'll fit a model including nuisance variables (i.e. variables we are not interested in, but that might affect the trait), like copepod block and stage. Essentially, this attempts to account for variation in the trait caused by the *environment*, Second, we will add selection line and generation to see if the selected lines diverged from each other over time. We will fit models using `MCMCglmm`, which is very flexible, allowing fixed and random effects, as well as different error structures.

For cercomere presence, we fit a generalized linear mixed model with block as a random effect, copepod stage as a fixed effect, inbreeding coefficient as a fixed effect, and binomial errors.

```{r}
# where want predictions for first model
pred_here1 <- dat%>%
  filter(cop_stage_checking != "",  gen_line == "0_base")%>%
  select(cop_stage_checking, gen_line)%>%
  distinct()
pred_here1$ib <- 0
pred_here1$cop_block <- unique(dat$cop_block)[3]
pred_here1$pred <- "yes1"

pred_here_ib <- data.frame(
  pred = "yesib", 
  cop_stage_checking = "C2",
  cop_block = unique(dat$cop_block)[3],
  gen_line = unique(dat$gen_line)[2],
  tank_id = unique(dat$tank_id)[3],
  ib = seq(
    min(dat$ib),
    max(dat$ib), 
    length.out = 50),
  fish_sex_cen = 0, 
  fish_initial_bm_cen = 0,
  log_fish_initial_bm_cen = 0,
  fish_exp_on_cop_dpe = 14)

# where want predictions for second model
pred_here2 <- dat%>%
  filter(cop_stage_checking != "")%>%
  filter(cop_stage_checking == "C2")%>% # most common stage
  select(cop_stage_checking, gen, line, gen_line)%>%
  distinct()
pred_here2$ib <- 0
pred_here2$cop_block <- unique(dat$cop_block)[3]
pred_here2$pred <- "yes2"

dat_cerc <- bind_rows(dat_cerc, pred_here1, pred_here_ib, pred_here2)
```

```{r}
target_post_dist_sample_size <- 2500
```

```{r}
p1_bi <- list(R = list(V = 1, fix = 1),
              G = list(G1 = list(V = 1, nu = 0.002)))

# # intercept-only
# m0_cerc <- MCMCglmm(cerc_bi ~ 1, 
#                  family = "categorical",
#                  data = dat%>%
#                    filter(cop_stage_checking != "", !is.na(cerc_bi)),
#                  prior = list(R = list(V = 1, fix = 1)),
#                  verbose=FALSE
#                  )
thin_cerc <- 75
burnin_cerc <- 1000
nit_cerc <- thin_cerc * target_post_dist_sample_size + burnin_cerc

# fixed effects
m1_cerc <- MCMCglmm(cerc_bi ~ cop_stage_checking + ib, 
                 random = ~cop_block,
                 family = "categorical",
                 data = dat_cerc,
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_cerc, 
                 thin = thin_cerc,
                 burnin = burnin_cerc
                )
# gen x selection line
m2_cerc <- MCMCglmm(cerc_bi ~ cop_stage_checking + ib + gen_line, 
                 random = ~cop_block,
                 family = "categorical",
                 data = dat_cerc,
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_cerc, 
                 thin = thin_cerc,
                 burnin = burnin_cerc
                )

```

The first model suggests that parasites develop slower in more developed copepods (C1 > C2 > C3, C4) and when there is inbreeding. It also suggests significant variation between experimental blocks.

```{r}
summary(m1_cerc)
```

Adding the selection line and generation into the model is an improvement; the model deviance decreases.

```{r}
plot(mcmc.list(m1_cerc$Deviance, m2_cerc$Deviance), density = F)
```

Here are the parameters of the second model. Several of the terms contrasting the selection lines are significant. Also, the variance attributed to "block" decreased, which makes sense, as it is overlaps with "generation".

```{r}
summary(m2_cerc)
```

Let's look at the marginal predictions from the models (i.e. excluding the random effect of block). 

```{r}
# # extract predicteds from model - need to correct location effects for fixed variance value
# pred_cerc1 <- predict.MCMCglmm(m1_cerc, type = 'terms', interval = "confidence")
# pred_cerc1 <- bind_cols(pred_here1, data.frame(boot::inv.logit(pred_cerc1[which(dat_cerc$pred == "yes1"),])))
# 
# pred_cerc2 <- predict.MCMCglmm(m2_cerc, type = 'terms', interval = "confidence")
# pred_cerc2 <- bind_cols(pred_here2, data.frame(boot::inv.logit(pred_cerc2[which(dat_cerc$pred == "yes2"),])))
```
```{r}
# the predictions returned by predict.mcmcglmm are a little biased because the residual var is set at 1. We can adjust the fixed model parameters according to Diggle (2004; see MCMCglmm course notes) and then re-estimate the predicted values
c2 <- ((16 * sqrt(3))/(15 * pi))^2

# first model
post_sol1 <- m1_cerc$Sol/sqrt(1 + c2 * m1_cerc$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_cerc$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_cerc$pred == "yes1") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_cerc$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here1,
                 cinf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_cerc1 <- px%>%
  pivot_longer(
    cols = cinf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(cop_stage_checking, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))%>%
  ungroup()

# IBD
post_sol1 <- m1_cerc$Sol/sqrt(1 + c2 * m1_cerc$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_cerc$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_cerc$pred == "yesib") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_cerc$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here_ib,
                 cinf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_cercib <- px%>%
  pivot_longer(
    cols = cinf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(ib, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))%>%
  ungroup()


# second model
post_sol2 <- m2_cerc$Sol/sqrt(1 + c2 * m2_cerc$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_cerc$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_cerc$pred == "yes2") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_cerc$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here2,
                 cinf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_cerc2 <- px%>%
  pivot_longer(
    cols = cinf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(gen, line, gen_line, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))%>%
  ungroup()
```

Here is the main effect of copepod stage from the first model. The open circle is the model estimate + CI. The solid circle is the raw, uncorrected average. The raw and model-derived estimates were similar, suggesting that copepod stage is rather randomized across experimental blocks.

```{r}
dx_avg <- dat_cerc%>%
  filter(is.na(pred))%>%
  group_by(cop_stage_checking)%>%
  summarise(cerc_prop = sum(cerc_bi)/sum(!is.na(cerc_bi)),
            n = n())

sf_copstage_a <- ggplot(pred_cerc1, aes(x = cop_stage_checking, y = fit)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr), shape = 1) +
  geom_point(data = dx_avg, aes(y = cerc_prop), shape = 16) +
  geom_text(data = dx_avg, aes(label = n, y = 0), vjust = 1) +
  # scale_y_continuous(limits = c(0,1)) +
  labs(y = "Proportion with cercomere 9 dpi") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
sf_copstage_a
```

Here is the effect of inbreeding.

```{r}
ggplot(pred_cercib, aes(x = ib, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2) +
  geom_line() +
  geom_rug(data = dat_cerc%>%filter(cerc_bi == 0), 
           aes(y = cerc_bi),
           sides = 'b', alpha = 0.1, position = "jitter") +
  geom_rug(data = dat_cerc%>%filter(cerc_bi == 1),
           aes(y = cerc_bi),
           sides = 't', alpha = 0.1, position = "jitter") +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Inbreeding coefficient", y = "Proportion with cercomere 9 dpi")
```
This is the predicted cercomere proportion without inbreeding: 

```{r}
post_cerc_noib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"cop_stage_checkingC2"])
posterior.mode(post_cerc_noib)
```

And here is the expected proportion from full-sib mating:

```{r}
post_cerc_ib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"cop_stage_checkingC2"] + post_sol1[,'ib']*.25)
posterior.mode(post_cerc_ib)
```
Here is the odds ratio associated with full-sib mating: 

```{r}
sx <- summary(
  post_cerc_ib/
  post_cerc_noib
)
sx
```

```{r}
sx <- round(sx$quantiles,2)
s_ann <- paste0("OR: ", sx[3], " [", sx[1], " - ", sx[5], "]")
```

The relationship may be easier to see without the data.

```{r}
sf_ib_a <- ggplot(pred_cercib, aes(x = ib, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2) +
  geom_line() +
  labs(x = "Inbreeding coefficient", y = "Proportion with cercomere 9 dpi") +
  annotate("text", label = s_ann, 
           x = 0,
           y = pred_cercib%>%.$lwr%>%min(),
           hjust = 0)
sf_ib_a
```

Now, let's plot the response to selection, the main goal of the experiment. Again, the open circle is the model estimate, this time estimated in C2 copepods, the most common stage in the experiment. The filled circle is the raw proportion. The model moves some values up or down, after accounting for stage and block. Importantly, it does not seem to bias the lines in any particular direction. 

```{r}
dx_avg <- dat_cerc%>%
  filter(is.na(pred))%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            cerc_prop = sum(cerc_bi)/sum(!is.na(cerc_bi))
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f3a <- ggplot(pred_cerc2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))), 
       aes(x = gen, y = fit, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = cerc_prop),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(pred_cerc2$lwr)),
            position = position_dodge2(width = dw+.2), 
            vjust = 1,
            size = 2) +
  # scale_y_continuous(limits = c(min(pred_cerc2$lwr),1)) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Proportion with cercomere 9 dpi",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank(), 
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0, 1))
f3a
```

By the end of the experiment, parasites in the 'fast' line developed significantly faster than those in the 'slow' line. As a measure of effect size, we can compare odds ratios among groups. All odds ratios hold copepod stage constant (at C2 level).

```{r}
# # get posterior predicteds for groups of interest (all in C2 cops)
# post_dist_0baseC2 <- boot::inv.logit(m2_cerc$Sol[,"(Intercept)"] + m2_cerc$Sol[,"cop_stage_checkingC2"])
# 
# post_dist_4ctrlC2 <- boot::inv.logit( m2_cerc$Sol[,"(Intercept)"] + m2_cerc$Sol[,"cop_stage_checkingC2"] +
#                                         m2_cerc$Sol[,"gen_line4_control"] )
# 
# post_dist_4fastC2 <- boot::inv.logit( m2_cerc$Sol[,"(Intercept)"] + m2_cerc$Sol[,"cop_stage_checkingC2"] +
#                                         m2_cerc$Sol[,"gen_line4_fast"] )
# 
# post_dist_4slowC2 <- boot::inv.logit( m2_cerc$Sol[,"(Intercept)"] + m2_cerc$Sol[,"cop_stage_checkingC2"] +
#                                         m2_cerc$Sol[,"gen_line4_slow"] )
# 
# # odds ratios
# # vs base
# odds_base_vs_fast4 <- post_dist_4fastC2/post_dist_0baseC2
# odds_base_vs_slow4 <- post_dist_4slowC2/post_dist_0baseC2
# 
# # vs control in last gen
# odds_ctrl4_vs_fast4 <- post_dist_4fastC2/post_dist_4ctrlC2
# odds_ctrl4_vs_slow4 <- post_dist_4slowC2/post_dist_4ctrlC2
# 
# # vs two lines
# odds_slow4_vs_fast4 <- post_dist_4fastC2/post_dist_4slowC2
```

```{r}
# get posterior predicteds for groups of interest (all in C2 cops)
post_dist_0baseC2 <- boot::inv.logit(post_sol2[,"(Intercept)"] + post_sol2[,"cop_stage_checkingC2"])

post_dist_4ctrlC2 <- boot::inv.logit( post_sol2[,"(Intercept)"] + post_sol2[,"cop_stage_checkingC2"] +
                                        post_sol2[,"gen_line4_control"] )

post_dist_4fastC2 <- boot::inv.logit( post_sol2[,"(Intercept)"] + post_sol2[,"cop_stage_checkingC2"] +
                                        post_sol2[,"gen_line4_fast"] )

post_dist_4slowC2 <- boot::inv.logit( post_sol2[,"(Intercept)"] + post_sol2[,"cop_stage_checkingC2"] +
                                        post_sol2[,"gen_line4_slow"] )

# odds ratios
# vs base
odds_base_vs_fast4 <- post_dist_4fastC2/post_dist_0baseC2
odds_base_vs_slow4 <- post_dist_4slowC2/post_dist_0baseC2

# vs control in last gen
odds_ctrl4_vs_fast4 <- post_dist_4fastC2/post_dist_4ctrlC2
odds_ctrl4_vs_slow4 <- post_dist_4slowC2/post_dist_4ctrlC2

# vs two lines
odds_slow4_vs_fast4 <- post_dist_4fastC2/post_dist_4slowC2
```

We start by comparing the selected lines in generation 4 with the initial base population. The parasites selected for faster development were about `r round(median(odds_base_vs_fast4), 1)` times as likely to have a cercomere. Even the lower CI of the odds was `r round((quantile(odds_base_vs_fast4, probs = 0.025)-1)*100, 1)` % larger than in the base population. 

```{r}
summary(odds_base_vs_fast4)
```

However, this comparison is somewhat inflated because all lines tended to have faster development after the first generation. By the end of the experiment, the slow line had a similar developmental rate to the base population (odd ratio overlapping 1).

```{r}
summary(odds_base_vs_slow4)
```

A better comparison is between control and selected lines in the final generation. Here, the odds of having a cercomere were about `r round((quantile(odds_ctrl4_vs_fast4, probs = 0.5)-1)*100, 1)` % higher in the fast line than the control line.

```{r}
summary(odds_ctrl4_vs_fast4)
```

The slow line was `r round((1-quantile(odds_ctrl4_vs_slow4, probs = 0.5))*100, 1)` % less likely to develop a cercomere than the control.

```{r}
summary(odds_ctrl4_vs_slow4)
```

And to show that selection in both directions worked, we can compare the fast and slow lines in the final generation. The fast line was about twice as likely to develop a cercomere.

```{r}
summary(odds_slow4_vs_fast4)
```

## Response vs selection differential

Another way to quantify the response to selection is to compare it with the selection differential. We expect stronger selection to cause a stronger response. With binary traits, the selection differential depends on the average proportion of individuals expressing a trait. For instance, it is harder and harder to select individuals for cercomere development when more and more have cercomeres. We used the calculations for binary traits presented in [Walsh and Lynch's 2018 book](https://www.google.de/books/edition/Evolution_and_Selection_of_Quantitative/L2liDwAAQBAJ?hl=en&gbpv=0) (see example on page 515). For this, we need the proportion of parasites with cercomeres in each generation, as well as the proportion of breeding parents with cercomeres.

```{r}
dat_cerc <- dat_cerc%>%
  mutate(line_next_gen = if_else(grepl(pattern = "^._C", eggs_clutch_id), "control",
                                 if_else(grepl(pattern = "^._F", eggs_clutch_id), "fast",
                                         if_else(grepl(pattern = "^._S", eggs_clutch_id), "slow", NA_character_))))
dx_breeders <- dat_cerc%>%
  filter(is.na(pred), used_breeding == 1)%>%
  group_by(gen, line, gen_line, line_next_gen)%>%
  summarise(n_breeders = n(),
            breeders_with_cerc = sum(cerc_bi),
            breeders_cerc_prop = sum(cerc_bi)/sum(!is.na(cerc_bi)),
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))
```

```{r}
# controls
ctrl <- dx_avg%>%
  mutate(liab_cerc = qnorm(cerc_prop))%>%
  filter(line %in% c("base", "control"))
ctrl <- left_join(ctrl, filter(dx_breeders, line_next_gen == "control")%>%
            select(gen, n_breeders, breeders_with_cerc, breeders_cerc_prop),
          by = "gen")
# response on liab scale
ctrl <- ctrl%>%
  mutate(liab_resp = liab_cerc - lag(liab_cerc))%>%
  mutate(cum_liab_resp = cumsum(coalesce(liab_resp, 0)) + liab_resp*0)
# selection differential
ctrl <- ctrl%>%
  mutate(sel_diff = (dnorm(liab_cerc)/cerc_prop) * 
           (breeders_cerc_prop - cerc_prop)/(1-cerc_prop))%>% # see Walsh and Lynch ex. 14.4
  mutate(sel_diff = lag(sel_diff)) %>%
  mutate(cum_sel_diff = cumsum(coalesce(sel_diff, 0)) + sel_diff*0)
```
```{r}
# fast
fast <- dx_avg%>%
  mutate(liab_cerc = qnorm(cerc_prop))%>%
  filter(line %in% c("base", "fast"))
fast <- left_join(fast, filter(dx_breeders, line_next_gen == "fast")%>%
            select(gen, n_breeders, breeders_with_cerc, breeders_cerc_prop),
          by = "gen")
# response on liab scale
fast <- fast%>%
  mutate(liab_resp = liab_cerc - lag(liab_cerc))%>%
  mutate(cum_liab_resp = cumsum(coalesce(liab_resp, 0)) + liab_resp*0)
# selection differential
fast <- fast%>%
  mutate(sel_diff = (dnorm(liab_cerc)/cerc_prop) * 
           (breeders_cerc_prop - cerc_prop)/(1-cerc_prop))%>% # see Walsh and Lynch ex. 14.4
  mutate(sel_diff = lag(sel_diff)) %>%
  mutate(cum_sel_diff = cumsum(coalesce(sel_diff, 0)) + sel_diff*0)
```
```{r}
# slow
slow <- dx_avg%>%
  mutate(liab_cerc = qnorm(cerc_prop))%>%
  filter(line %in% c("base", "slow"))
slow <- left_join(slow, filter(dx_breeders, line_next_gen == "slow")%>%
            select(gen, n_breeders, breeders_with_cerc, breeders_cerc_prop),
          by = "gen")
# response on liab scale
slow <- slow%>%
  mutate(liab_resp = liab_cerc - lag(liab_cerc))%>%
  mutate(cum_liab_resp = cumsum(coalesce(liab_resp, 0)) + liab_resp*0)
# selection differential
slow <- slow%>%
  mutate(sel_diff = (dnorm(liab_cerc)/cerc_prop) * 
           (breeders_cerc_prop - cerc_prop)/(1-cerc_prop))%>% # see Walsh and Lynch ex. 14.4
  mutate(sel_diff = lag(sel_diff)) %>%
  mutate(cum_sel_diff = cumsum(coalesce(sel_diff, 0)) + sel_diff*0)
```

We first calculated selection differentials and responses using the raw data, uncorrected for copepod stage or block.

```{r}
sel_diff_out <- bind_rows(ctrl, fast, slow)%>%
  filter(line != "base")%>%
  mutate(line = fct_relevel(line, c("fast", "control", "slow")))
```

Here is the cumulative response to selection as a function of the cumulative selection differential. The labels indicate generation. One thing to notice is that the cumulative selection differential is comparable in fast and slow lines. The maximum in the fast line was `r filter(sel_diff_out, line == "fast")%>%.$cum_sel_diff%>%max()%>%round(.,2)`, whereas the minimum in the slow line was `r filter(sel_diff_out, line == "slow")%>%.$cum_sel_diff%>%min()%>%round(.,2)`. The line indicates that there was a response to selection, whereas the slope is the realized heritability.

```{r}
ggplot(sel_diff_out, aes(x = cum_sel_diff, y = cum_liab_resp)) +
  geom_smooth(method = lm, se = F, color = "gray", linetype = "dashed") +
  geom_point(aes(color = line), shape = 1, size = 5) +
  geom_text(aes(label = gen, color = line)) +
  scale_color_manual(values = c("red", "black", "blue")) +
  labs(x = "Cum. selection differential", y = "Cum. response to selection\n(liability scale)") +
  theme(legend.title = element_blank())
```

Here is the slope:

```{r}
summary(lm(cum_liab_resp ~ cum_sel_diff, data = sel_diff_out))
```

The realized heritability may be decreased by the environmental noise in the data. Thus, let's make the same plot, but this time use means corrected for experimental block and copepod stage (i.e. the model means).

```{r}
# controls
ctrl <- pred_cerc2%>%
  rename(cerc_prop = fit)%>%
  mutate(liab_cerc = qnorm(cerc_prop))%>%
  filter(line %in% c("base", "control"))
ctrl <- left_join(ctrl, filter(dx_breeders, line_next_gen == "control")%>%
            select(gen, n_breeders, breeders_with_cerc, breeders_cerc_prop),
          by = "gen")
# response on liab scale
ctrl <- ctrl%>%
  mutate(liab_resp = liab_cerc - lag(liab_cerc))%>%
  mutate(cum_liab_resp = cumsum(coalesce(liab_resp, 0)) + liab_resp*0)
# selection differential
ctrl <- ctrl%>%
  mutate(sel_diff = (dnorm(liab_cerc)/cerc_prop) * 
           (breeders_cerc_prop - cerc_prop)/(1-cerc_prop))%>% # see Walsh and Lynch ex. 14.4
  mutate(sel_diff = lag(sel_diff)) %>%
  mutate(cum_sel_diff = cumsum(coalesce(sel_diff, 0)) + sel_diff*0)

# fast
fast <- pred_cerc2%>%
  rename(cerc_prop = fit)%>%
  mutate(liab_cerc = qnorm(cerc_prop))%>%
  filter(line %in% c("base", "fast"))
fast <- left_join(fast, filter(dx_breeders, line_next_gen == "fast")%>%
            select(gen, n_breeders, breeders_with_cerc, breeders_cerc_prop),
          by = "gen")
# response on liab scale
fast <- fast%>%
  mutate(liab_resp = liab_cerc - lag(liab_cerc))%>%
  mutate(cum_liab_resp = cumsum(coalesce(liab_resp, 0)) + liab_resp*0)
# selection differential
fast <- fast%>%
  mutate(sel_diff = (dnorm(liab_cerc)/cerc_prop) * 
           (breeders_cerc_prop - cerc_prop)/(1-cerc_prop))%>% # see Walsh and Lynch ex. 14.4
  mutate(sel_diff = lag(sel_diff)) %>%
  mutate(cum_sel_diff = cumsum(coalesce(sel_diff, 0)) + sel_diff*0)

# slow
slow <- pred_cerc2%>%
  rename(cerc_prop = fit)%>%
  mutate(liab_cerc = qnorm(cerc_prop))%>%
  filter(line %in% c("base", "slow"))
slow <- left_join(slow, filter(dx_breeders, line_next_gen == "slow")%>%
            select(gen, n_breeders, breeders_with_cerc, breeders_cerc_prop),
          by = "gen")
# response on liab scale
slow <- slow%>%
  mutate(liab_resp = liab_cerc - lag(liab_cerc))%>%
  mutate(cum_liab_resp = cumsum(coalesce(liab_resp, 0)) + liab_resp*0)
# selection differential
slow <- slow%>%
  mutate(sel_diff = (dnorm(liab_cerc)/cerc_prop) * 
           (breeders_cerc_prop - cerc_prop)/(1-cerc_prop))%>% # see Walsh and Lynch ex. 14.4
  mutate(sel_diff = lag(sel_diff)) %>%
  mutate(cum_sel_diff = cumsum(coalesce(sel_diff, 0)) + sel_diff*0)
```

```{r}
sel_diff_out2 <- bind_rows(ctrl, fast, slow)%>%
  filter(line != "base")%>%
  mutate(line = fct_relevel(line, c("fast", "control", "slow")))
```

The pattern is similar, though it does seem like we removed some of the variation around the relationship.

```{r}
f3b <- ggplot(sel_diff_out2, aes(x = cum_sel_diff, y = cum_liab_resp)) +
  geom_smooth(method = lm, se = F, color = "gray", linetype = "dashed") +
  geom_point(aes(color = line), shape = 1, size = 5) +
  geom_text(aes(label = gen, color = line)) +
  scale_color_manual(values = c("red", "black", "blue")) +
  labs(x = "Cum. selection differential", y = "Cum. response to selection\n(liability scale)") +
  theme(legend.title = element_blank())
f3b
```

Accordingly, the realized heritability estimate increased slightly.

```{r}
summary(lm(cum_liab_resp ~ cum_sel_diff, data = sel_diff_out2))
```

# Correlated selection responses

Since we observed a response to selection, we can ask if any other parasite traits had a correlated response due to underlying genetic correlations. One possibility is that fast developers are more virulent and likely to kill their copepod hosts - we tested this in a separate experiment that is analysed in a different [notebook](03virulence_in_final_generation.md). Within the larger selection experiment, we recorded several fitness components in the parasites. We go through this traits one by one. 

## Traits in copepods

### Copepod infection rate

We usually checked copepods for infection within a few days of exposure; 90% were checked after 2 or 3 days. Thus, there was little opportunity for differential mortality to bias estimates of infection rate.

```{r}
# round(prop.table(table(dat$cop_checked_dpe)),2)
```

In total, this many copepods were checked for infection:

```{r}
sum(!is.na(dat$cop_inf))
```

A few, though, lacked stage information, so we end up with this many copepods for the model:

```{r}
sum(!is.na(dat$cop_inf) & dat$cop_stage_checking!="")
```
We'll fit essentially the same models for copepod infection that we did for cercomere presence: first, inbreeding coef, copepod block and stage as nuisance variables, then add generation and selection line.

```{r}
dat_cinf <- filter(dat, !is.na(cop_inf), cop_stage_checking != "")

dat_cinf <- bind_rows(dat_cinf, pred_here1, pred_here2, pred_here_ib)
```
```{r}
p1_bi <- list(R = list(V = 1, fix = 1),
              G = list(G1 = list(V = 1, nu = 0.002)))

thin_cinf <- 100
burnin_cinf <- 1000
nit_cinf <- thin_cinf * target_post_dist_sample_size + burnin_cinf

# fixed effects
m1_cinf <- MCMCglmm(cop_inf ~ cop_stage_checking + ib, 
                 random = ~cop_block,
                 family = "categorical",
                 data = dat_cinf,
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_cinf, 
                 thin = thin_cinf,
                 burnin = burnin_cinf
                )
# gen x selection line
m2_cinf <- MCMCglmm(cop_inf ~ cop_stage_checking + ib + gen_line, 
                 random = ~cop_block,
                 family = "categorical",
                 data = dat_cinf,
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_cinf, 
                 thin = thin_cinf,
                 burnin = burnin_cinf
                )

```

Similar to cercomere presence, we see a trend for lower susceptibility in more developed copepods. Inbreeding is also associated with lower infection rates. There is also  variation between blocks - sometimes infection rates are higher, sometimes they are lower.

```{r}
summary(m1_cinf)
```

Adding the selection line and generation into the model looks like a slight improvement based on the model deviance.

```{r}
plot(mcmc.list(m1_cinf$Deviance, m2_cinf$Deviance), density = F)
```

Here are the parameters of the second model. As before, the the variance attributed to "block" decreased, and several of the terms contrasting the selection lines are significant.

```{r}
summary(m2_cinf)
```

Let's look at the marginal predictions from the models (i.e. excluding the random effect of block). 

```{r}
# # returns somewhat biased estimates
# pred_cinf1 <- predict.MCMCglmm(m1_cinf, type = 'terms', interval = "confidence")
# pred_cinf1 <- bind_cols(pred_here1, data.frame(boot::inv.logit(pred_cinf1[which(dat_cinf$pred == "yes1"),])))
# 
# pred_cinf2 <- predict.MCMCglmm(m2_cinf, type = 'terms', interval = "confidence")
# pred_cinf2 <- bind_cols(pred_here2, data.frame(boot::inv.logit(pred_cinf2[which(dat_cinf$pred == "yes2"),])))
```

```{r}
# manual prediction, correcting for set variance comp
c2 <- ((16 * sqrt(3))/(15 * pi))^2

# first model
post_sol1 <- m1_cinf$Sol/sqrt(1 + c2 * m1_cinf$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_cinf$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_cinf$pred == "yes1") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_cinf$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here1,
                 cinf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_cinf1 <- px%>%
  pivot_longer(
    cols = cinf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(cop_stage_checking, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))


# IBD
post_sol1 <- m1_cinf$Sol/sqrt(1 + c2 * m1_cinf$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_cinf$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_cinf$pred == "yesib") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_cinf$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here_ib,
                 cinf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_cinfib <- px%>%
  pivot_longer(
    cols = cinf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(ib, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))%>%
  ungroup()

# second model
post_sol2 <- m2_cinf$Sol/sqrt(1 + c2 * m2_cinf$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_cinf$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_cinf$pred == "yes2") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_cinf$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here2,
                 cinf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_cinf2 <- px%>%
  pivot_longer(
    cols = cinf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(gen, line, gen_line, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

Here is the main effect of copepod stage from the first model. Larger copepods are less susceptible.

```{r}
dx_avg <- dat_cinf%>%
  filter(is.na(pred))%>%
  group_by(cop_stage_checking)%>%
  summarise(cinf_prop = sum(cop_inf)/sum(!is.na(cop_inf)),
            n = n())

sf_copstage_b <- ggplot(pred_cinf1, aes(x = cop_stage_checking, y = fit)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr), shape = 1) +
  geom_point(data = dx_avg, aes(y = cinf_prop), shape = 16) +
  geom_text(data = dx_avg, aes(label = n, y = min(pred_cinf1$lwr)), vjust = 1) +
  # scale_y_continuous(limits = c(min(pred_cinf1$lwr),1)) +
  labs(y = "Copepod infection rate") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
sf_copstage_b
```

Here is the effect of inbreeding.

```{r}
ggplot(pred_cinfib, aes(x = ib, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2) +
  geom_line() +
  geom_rug(data = dat_cinf%>%filter(cop_inf == 0)%>%slice_sample(prop=0.25), 
           aes(y = cop_inf),
           sides = 'b', alpha = 0.1, position = "jitter") +
  geom_rug(data = dat_cinf%>%filter(cop_inf == 1)%>%slice_sample(prop=0.25),
           aes(y = cop_inf),
           sides = 't', alpha = 0.1, position = "jitter") +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Inbreeding coefficient", y = "Copepod infection rate")
```

This is the predicted infection rate proportion without inbreeding: 

```{r}
post_cinf_noib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"cop_stage_checkingC2"])
posterior.mode(post_cinf_noib)
```
And here is the expected proportion from full-sib mating:

```{r}
post_cinf_ib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"cop_stage_checkingC2"] + post_sol1[,'ib']*.25)
posterior.mode(post_cinf_ib)
```
Here is the odds ratio associated with full-sib mating: 

```{r}
sx <- summary(
  post_cinf_ib/
  post_cinf_noib
)
sx
```
```{r}
sx <- round(sx$quantiles,2)
s_ann <- paste0("OR: ", sx[3], " [", sx[1], " - ", sx[5], "]")
```

The relationship may be easier to see without the data.

```{r}
sf_ib_b <- ggplot(pred_cinfib, aes(x = ib, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2) +
  geom_line() +
  labs(x = "Inbreeding coefficient", y = "Copepod infection rate") +
  annotate("text", label = s_ann, 
           x = 0,
           y = pred_cinfib%>%.$lwr%>%min(),
           hjust = 0)
sf_ib_b
```

And here is the effect of lines on copepod infection. There was not a consistent difference. Perhaps the infection rate in the fast line decreased over time. But these differences seem small in general.

```{r}
dx_avg <- dat_cinf%>%
  filter(is.na(pred))%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            cinf_prop = sum(cop_inf)/sum(!is.na(cop_inf))
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4a <- ggplot(pred_cinf2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = cinf_prop),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(pred_cinf2$lwr)),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  # scale_y_continuous(limits = c(min(pred_cinf2$lwr),1)) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Copepod infection rate",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4a
```

### Procercoid size

Another trait associated with fitness is procercoid size - larger procercoids are more likely to establish infection in fish. We recorded parasite size 13 dpi for worms that were above the copepod gut (those below are hard to photograph and measure in vivo). When recording parasite size, copepod length was also measured. So, one strategy would be to use copepod size instead of stage in the model. However, copepod length was closely related to copepod stage at checking.

```{r}
ggplot(filter(dat, cop_stage_checking != ""),
       aes(x=cop_stage_checking, y = cop_length_mm)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(alpha = 0.1)
```

Since copepod stage was recorded earlier in the infection and thus better represents starting conditions (e.g. parasites could influence host growth), let's keep stage in our model. Thus, we are fitting the same two models as above, but with gaussian instead of binomial errors.

Here is the number of parasites that were measured as procercoids:

```{r}
sum(!is.na(dat$proc_size2))
```

```{r}
dat_proc<- filter(dat, !is.na(proc_size2), cop_stage_checking != "")

dat_proc <- bind_rows(dat_proc, pred_here1, pred_here2, pred_here_ib)
```
```{r}
p1_g <- list(R = list(V = 1, nu = 0.002),
             G = list(G1 = list(V = 1, nu = 0.002)))

thin_proc <- 100
burnin_proc <- 1000
nit_proc <- thin_proc * target_post_dist_sample_size + burnin_proc

# fixed effects
m1_proc <- MCMCglmm(proc_size2 ~ cop_stage_checking + ib, 
                 random = ~cop_block,
                 family = "gaussian",
                 data = dat_proc,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_proc, 
                 thin = thin_proc,
                 burnin = burnin_proc
                )
# gen x selection line
m2_proc <- MCMCglmm(proc_size2 ~ cop_stage_checking + ib + gen_line, 
                 random = ~cop_block,
                 family = "gaussian",
                 data = dat_proc,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_proc, 
                 thin = thin_proc,
                 burnin = burnin_proc
                )
```

Although parasites developed fastest in small copepods, they grow biggest in big coppepods. Inbred worms were slightly smaller. There is also  variation between experimental blocks.

```{r}
summary(m1_proc)
```

Adding the selection line and generation into the model is an improvement based on the model deviance.

```{r}
plot(mcmc.list(m1_proc$Deviance, m2_proc$Deviance), density = F)
```

Here are the parameters of the second model. The 'block' variance decreased a bit. Some of the parameters for selection lines are significant, but only marginally so.

```{r}
summary(m2_proc)
```

Let's look at the marginal predictions from the models (i.e. excluding the random effect of block). 

```{r}
pred_proc1x <- predict.MCMCglmm(m1_proc, interval = "confidence")
pred_proc1 <- bind_cols(pred_here1, data.frame(pred_proc1x[which(dat_proc$pred == "yes1"),]))
pred_procib <- bind_cols(pred_here_ib, data.frame(pred_proc1x[which(dat_proc$pred == "yesib"),]))
rm(pred_proc1x)

pred_proc2 <- predict.MCMCglmm(m2_proc, interval = "confidence")
pred_proc2 <- bind_cols(pred_here2, data.frame(pred_proc2[which(dat_proc$pred == "yes2"),]))
```

Here is the main effect of copepod stage from the first model.

```{r}
dx_avg <- dat_proc%>%
  filter(is.na(pred))%>%
  group_by(cop_stage_checking)%>%
  summarise(proc_mean = mean(proc_size2, na.rm=T),
            n = n())

sf_copstage_c <- ggplot(pred_proc1, aes(x = cop_stage_checking, y = fit/1000)) +
  geom_pointrange(aes(ymin = lwr/1000, ymax = upr/1000), shape = 1) +
  geom_point(data = dx_avg, aes(y = proc_mean/1000), shape = 16) +
  geom_text(data = dx_avg, aes(label = n, y = min(pred_proc1$lwr/1000)), vjust = 1) +
  labs(y =  bquote("Procercoid size 13 dpi "(~mm^2))) +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
sf_copstage_c
```

Parasites that infected C3s were this much larger than those in C1s (in percent):

```{r}
summary(
  ((m1_proc$Sol[,"cop_stage_checkingC3"] + m1_proc$Sol[,"(Intercept)"]) -
   m1_proc$Sol[,"(Intercept)"])/m1_proc$Sol[,"(Intercept)"]
  * 100)
```

Here is the effect of inbreeding. There is a very slight negative trend.

```{r}
ggplot(pred_procib, aes(x = ib, y = fit/1000)) +
  geom_point(data = dat_proc, aes(x = ib, y = proc_size2/1000), alpha = 0.1) +
  geom_ribbon(aes(ymin = lwr/1000, ymax = upr/1000), alpha = 0.2) +
  geom_line() +
  labs(x = "Inbreeding coefficient",
       y =  bquote("Procercoid size "(~mm^2))) 
```

Full-sib mating decreases procercoid size by this percent: 

```{r}
post_proc_noib <- m1_proc$Sol[,"(Intercept)"] + m1_proc$Sol[,"cop_stage_checkingC2"]
post_proc_ib <- m1_proc$Sol[,"(Intercept)"] + m1_proc$Sol[,"cop_stage_checkingC2"] + 
  m1_proc$Sol[,'ib']*.25
sx <- summary(100*(post_proc_noib - post_proc_ib)/post_proc_noib)
sx
```
```{r}
sx <- round(sx$quantiles,1)
s_ann <- paste0("PD: ", sx[3], "% [", sx[1], " - ", sx[5], "]")
```

```{r}
sf_ib_c <- ggplot(pred_procib, aes(x = ib, y = fit/1000)) +
  geom_ribbon(aes(ymin = lwr/1000, ymax = upr/1000), alpha = 0.2) +
  geom_line() +
  labs(x = "Inbreeding coefficient",
       y =  bquote("Procercoid size "(~mm^2))) +
  annotate("text", label = s_ann, 
           x = 0,
           y = pred_procib%>%.$lwr%>%min()/1000,
           hjust = 0)
sf_ib_c
```

And here is the change in procercoid size over time. Although worm size varied a bit from one generation to the next, there were not clear differences between the selection lines.

```{r}
dx_avg <- dat_proc%>%
  filter(is.na(pred))%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            proc_mean = mean(proc_size2, na.rm=T),
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4b <- ggplot(pred_proc2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit/1000, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr/1000, ymax = upr/1000),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = proc_mean/1000),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(pred_proc2$lwr/1000)),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y =  bquote("Procercoid size 13 dpi "(~mm^2)),
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4b
```

### Developmental defects

When measuring worms at 13 dpi, some worms had clearly not developed normally; they lacked a cercomere after 13 days or had not grown much. About 95% of worms developed normally, but a few exhibited defects. 

```{r}
prop.table(table(dat$failed_devo_bi))
```
In total, this many parasites were scored for defects:

```{r}
sum(!is.na(dat$failed_devo_bi))
```

Here is a comparison of the size of worms that did and did not develop normally. The left-tail of the distribution, the smallest parasites, are made up of parasites that did not develop properly.

```{r}
cowplot::plot_grid(
  ggplot(filter(dat, !is.na(failed_devo_bi)),
         aes(x=proc_size2, fill=factor(failed_devo_bi))) +
    geom_histogram(alpha=0.75) + labs( x="Procercoid size") + guides(fill = "none"),
  ggplot(filter(dat, !is.na(failed_devo_bi)),
         aes(x=proc_size2, fill=factor(failed_devo_bi))) +
    geom_density(alpha=0.5) + labs(fill="Fail", x="Procercoid size"))
```

Let's model this binary trait like we did for copepod infection and cercomere presence: first, copepod block and stage as nuisance variables, then add generation and selection line.

```{r}
dat_fail <- filter(dat, !is.na(failed_devo_bi), cop_stage_checking != "")

dat_fail <- bind_rows(dat_fail, pred_here1, pred_here2, pred_here_ib)
```
```{r}
p1_bi <- list(R = list(V = 1, fix = 1),
              G = list(G1 = list(V = 1, nu = 0.002)))

thin_fail <- 250
burnin_fail <- 1000
nit_fail <- thin_fail * target_post_dist_sample_size + burnin_fail

# fixed effects
m1_fail <- MCMCglmm(failed_devo_bi ~ cop_stage_checking + ib, 
                 random = ~cop_block,
                 family = "categorical",
                 data = dat_fail,
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_fail, 
                 thin = thin_fail,
                 burnin = burnin_fail
                )
# gen x selection line
m2_fail <- MCMCglmm(failed_devo_bi ~ cop_stage_checking + ib + gen_line, 
                 random = ~cop_block,
                 family = "categorical",
                 data = dat_fail,
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_fail, 
                 thin = thin_fail,
                 burnin = burnin_fail
                )

```

Copepod stage does not have an obvious effect, although failed development was a little more common in C3s than C1/C2s. There is a clear effect of inbreeding. We do not see clear variation among blocks, suggesting environmental 'noise' does not cause developmental defects.

```{r}
summary(m1_fail)
```

Adding the selection line and generation into the model looks like an improvement.

```{r}
plot(mcmc.list(m1_fail$Deviance, m2_fail$Deviance), density = F)
```

The parameters of the second model suggest that failure is more likely in the 'slow' line.

```{r}
summary(m2_fail)
```

Let's plot the marginal predictions from the models (i.e. excluding the random effect of block). 

```{r}
# manual prediction, correcting for set variance comp
c2 <- ((16 * sqrt(3))/(15 * pi))^2

# first model
post_sol1 <- m1_fail$Sol/sqrt(1 + c2 * m1_fail$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_fail$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_fail$pred == "yes1") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_fail$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here1,
                 fail_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_fail1 <- px%>%
  pivot_longer(
    cols = fail_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(cop_stage_checking, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

# first model, inbreeding
post_sol1 <- m1_fail$Sol/sqrt(1 + c2 * m1_fail$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_fail$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_fail$pred == "yesib") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_fail$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here_ib,
                 fail_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_failib <- px%>%
  pivot_longer(
    cols = fail_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(ib, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))


# second model
post_sol2 <- m2_fail$Sol/sqrt(1 + c2 * m2_fail$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_fail$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_fail$pred == "yes2") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_fail$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here2,
                 fail_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_fail2 <- px%>%
  pivot_longer(
    cols = fail_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(gen, line, gen_line, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

Failed development is a bit more common in the older copepods, which fits with the pattern for cercomere development. 

```{r}
dx_avg <- dat_fail%>%
  filter(is.na(pred))%>%
  group_by(cop_stage_checking)%>%
  summarise(fail_prop = sum(failed_devo_bi)/sum(!is.na(failed_devo_bi)),
            n = n())

sf_copstage_d <- ggplot(pred_fail1, aes(x = cop_stage_checking, y = fit)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr), shape = 1) +
  geom_point(data = dx_avg, aes(y = fail_prop), shape = 16) +
  geom_text(data = dx_avg, aes(label = n, y = 0), vjust = 1) +
  scale_y_continuous(limits = c(0,max(pred_fail1$upr))) +
  labs(y = "Failed development 13 dpi") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
sf_copstage_d
```

Inbreeding increases the chance of developmental failure.

```{r}
ggplot(pred_failib, aes(x = ib, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2) +
  geom_line() +
  geom_rug(data = dat_fail%>%filter(failed_devo_bi == 0)%>%slice_sample(prop=0.55), 
           aes(y = failed_devo_bi),
           sides = 'b', alpha = 0.1, position = "jitter") +
  geom_rug(data = dat_fail%>%filter(failed_devo_bi == 1)%>%slice_sample(prop=0.55),
           aes(y = failed_devo_bi),
           sides = 't', alpha = 0.1, position = "jitter") +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Inbreeding coefficient", y = "Failed development rate")
```

This is the predicted failure rate without inbreeding: 

```{r}
post_fail_noib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"cop_stage_checkingC2"])
posterior.mode(post_fail_noib)
```

And here is the rate with full-sib mating:

```{r}
post_fail_ib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"cop_stage_checkingC2"] + post_sol1[,'ib']*.25)
posterior.mode(post_fail_ib)
```
Here is the odds ratio for failed development associated with full-sib mating: 

```{r}
summary(
  post_fail_ib/
  post_fail_noib
)
```
Alternatively, the odds ratio can be expressed as how much full-sib mating decreases successful development:

```{r}
sx <- summary(
  post_fail_noib/
  post_fail_ib
)
sx
```
```{r}
sx <- round(sx$quantiles,2)
s_ann <- paste0("OR: ", sx[3], " [", sx[1], " - ", sx[5], "]")
```

The relationship may be easier to see without the data and flipped so that inbreeding decreases successful development.

```{r}
sf_ib_d <- ggplot(pred_failib, aes(x = ib, y = 1-fit)) +
  geom_ribbon(aes(ymin = 1-upr, ymax = 1-lwr), alpha = 0.2) +
  geom_line() +
  labs(x = "Inbreeding coefficient", y = "Successful development 13 dpi") +
  annotate("text", label = s_ann, 
           x = 0,
           y = min(1-pred_failib%>%.$upr),
           hjust = 0)
sf_ib_d
```


And here is the dependence of failure on selection line. Selection for slow development seems to more often cause failed development. Perhaps selection is revealing some hidden genetic load in this line.

```{r}
dx_avg <- dat_fail%>%
  filter(is.na(pred))%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            fail_prop = sum(failed_devo_bi)/sum(!is.na(failed_devo_bi))
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4c <- ggplot(pred_fail2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = fail_prop),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = 0),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_y_continuous(limits = c(0,max(pred_fail2$upr))) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Failed development 13 dpi",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4c
```

```{r}
# # Also invert and express as successful development!
# dx_avg <- dat_fail%>%
#   filter(is.na(pred))%>%
#   group_by(gen, line, gen_line)%>%
#   summarise(n = n(),
#             fail_prop = sum(failed_devo_bi)/sum(!is.na(failed_devo_bi))
#             )%>%
#   ungroup()%>%
#   mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))
# 
# dw <- 0.6
# f4c <- ggplot(pred_fail2%>%
#          mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
#        aes(x = gen, y = 1-fit, color = line)) +
#   geom_line(aes(group = line),
#             position = position_dodge2(width = dw)) +
#   geom_pointrange(aes(ymin = 1-upr, ymax = 1-lwr),
#                   position = position_dodge2(width = dw),
#                   shape = 1) +
#   geom_point(data = dx_avg, 
#              aes(y = 1-fail_prop),
#              position = position_dodge2(width = dw), 
#              shape = 16) +
#   geom_text(data = dx_avg, 
#             aes(label = n, y = 1-max(pred_fail2$upr)),
#             position = position_dodge2(width = dw+.25), 
#             vjust = 1,
#             size = 2) +
#   # scale_y_continuous(limits = c(0,max(pred_fail2$upr))) +
#   scale_color_manual(values = c("gray", "red", "black", "blue")) +
#   labs(y = "Successful development rate in copepods",
#        x = "Generation") +
#   theme(panel.grid.major.x = element_blank(),
#         legend.title = element_blank())
# f4c
```

Here is the odds ratio comparing slow and control lines in the final generation.

```{r}
# get posterior predicteds for gen 4, day 12
post_dist_4slowfail <- boot::inv.logit(
  post_sol2[,"(Intercept)"] + post_sol2[,"cop_stage_checkingC2"] + post_sol2[,"gen_line4_slow"]
    )
post_dist_4cntrfail <- boot::inv.logit(
  post_sol2[,"(Intercept)"] + post_sol2[,"cop_stage_checkingC2"] + post_sol2[,"gen_line4_control"]
    )

# odds ratios, day 12
odds_ctrl_vs_slow_fail <- post_dist_4slowfail/post_dist_4cntrfail
```
```{r}
summary(odds_ctrl_vs_slow_fail)
```

### Copepod survival

On day 13 post infection, copepods were checked for survival. Usually this was done as part of measuring worm size, before exposing fish on day 14. However, in the final generation, some infected copepods were taken to infect fish at 12 dpe (to test the evolution of faster development). These copepods were thus excluded from the survival measurement. Note that in a separate experiment in the final generation we also examined host survival under starvation over a longer observation period. That is analysed [elsewhere](03virulence_in_final_generation.md).

We can look at copepod survival during the experiment in two steps. First, we can check whether infection affects survival. Second, we can see if parasites from the different lines affect host survival differently. 

Here is the number of copepods for which both survival and infection were recorded:

```{r}
sum(!is.na(dat$cop_inf) & !is.na(dat$cop_dead_13dpe))
```

The proportion of copepods dying did not massively differ between uninfecteds and infecteds (about 20% in each case):

```{r}
round(prop.table(with(dat, table(cop_inf, cop_dead_13dpe)),margin = 1),2)
```

Let's test whether there is an effect of infection on survival. As before, we fit a model (binomial errors) with with copepod stage and block, but we also include copepod infection as a fixed effect. Infection may generally decrease survival or only decrease it in particular stages. Therefore, we first fit a model with just the main effect of infection, and then with an interaction between stage and infection.

```{r}
# for inf vs uninf
dat_surv13 <- filter(dat, !is.na(cop_dead_13dpe), cop_stage_checking != "", !is.na(cop_inf))
pred_surv_inf <- bind_rows(pred_here1,
                           pred_here1)
pred_surv_inf$cop_inf <- rep(c(0,1), each=4)
dat_surv13 <- bind_rows(dat_surv13, pred_surv_inf)

# for fast vs slow
dat_surv13_2 <- dat%>%
  filter(!is.na(cop_dead_13dpe), cop_stage_checking != "", !is.na(cop_inf))%>%
  filter(cop_inf == 1)%>%
  mutate(cop_stage_checking = fct_infreq(cop_stage_checking))%>%
  bind_rows(pred_here1, pred_here2, pred_here_ib)
```

```{r}
thin_surv <- 75
burnin_surv <- 1000
nit_surv <- thin_surv * target_post_dist_sample_size + burnin_surv

# fixed effects
m0_surv_inf <- MCMCglmm(cop_dead_13dpe ~ cop_stage_checking + cop_inf, 
                        random = ~cop_block,
                 family = "categorical",
                 data = dat_surv13%>%
                   mutate(cop_stage_checking = fct_infreq(cop_stage_checking)),
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_surv, 
                 thin = thin_surv,
                 burnin = burnin_surv
                )

m0_surv_inf_int <- MCMCglmm(cop_dead_13dpe ~ cop_stage_checking * factor(cop_inf), 
                        random = ~cop_block,
                 family = "categorical",
                 data = dat_surv13%>%
                   mutate(cop_stage_checking = fct_infreq(cop_stage_checking)),
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_surv, 
                 thin = thin_surv,
                 burnin = burnin_surv
                )
```

This model suggests there are differences in mortality between experimental blocks and copepod stages. Small copepods have higher mortality. Finally, infected copepods have an elevated mortality rate.

```{r}
summary(m0_surv_inf)
```

Here is the odds ratio comparing infected and uninfected copepods (in C2s):

```{r}
summary(exp(m0_surv_inf$Sol[,"cop_inf"]))
```

The model with an interaction between stage and infection was not clearly better.

```{r}
plot(mcmc.list(m0_surv_inf$Deviance, m0_surv_inf_int$Deviance), density = F)
```

However, the model parameters suggest infection mainly affects the survival of C1s. Let's plot these results.

```{r}
summary(m0_surv_inf_int)
```

```{r}
# manual prediction, correcting for set variance comp
# first model
post_sol1 <- m0_surv_inf_int$Sol/sqrt(1 + c2 * m0_surv_inf_int$VCV[, 'units']) # correction suggested in course notes
pdx <- m0_surv_inf_int$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_surv13$pred == "yes1") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m0_surv_inf_int$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_surv_inf,
                 surv_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_surv0 <- px%>%
  pivot_longer(
    cols = surv_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(cop_stage_checking, cop_inf, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

Infection mainly reduced survival in C1s, the smallest copepods.

```{r}
dx_avg <- dat_surv13%>%
  filter(is.na(pred))%>%
  group_by(cop_stage_checking, cop_inf)%>%
  summarise(surv_prop = sum(cop_dead_13dpe)/sum(!is.na(cop_dead_13dpe)),
            n = n())

sf_copstage_e <- ggplot(pred_surv0, 
       aes(x = cop_stage_checking, y = 1-fit, 
           shape = factor(cop_inf),
           color = factor(cop_inf),
           fill = factor(cop_inf))) +
  geom_pointrange(
    aes(ymin = 1-upr, ymax = 1-lwr), 
    position = position_dodge2(width = dw),
    fill = "white"
    ) +
  geom_point(data = dx_avg, aes(y = 1-surv_prop),
             position = position_dodge2(width = dw)
             ) +
  geom_text(data = dx_avg, aes(label = n, y = 1-max(pred_surv0$upr)), vjust = 1,
            position = position_dodge2(width = dw+.2),
            size = 2.5) +
  scale_shape_manual(values = c(22,21), labels = c("uninfected", "infected")) +
  scale_color_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  scale_fill_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  labs(y = "Copepod survival rate 13 dpe", shape = "Infection") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank(),
        legend.title = element_blank(),
        legend.background = element_rect(color="black"),
        legend.position = c(.6,.5),
        legend.justification = c(0,1))
sf_copstage_e
```
```{r}
sf_copstage <- cowplot::plot_grid(
  sf_copstage_b + theme(axis.text.x = element_blank(),
                        axis.title.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  sf_copstage_a + theme(axis.text.x = element_blank(),
                        axis.title.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  sf_copstage_c + theme(axis.title.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  sf_copstage_d,
  sf_copstage_e + guides(fill = "none", color = "none"),
  NULL,
  align = "hv",
  ncol = 3,
  labels = c("A", "B", "C", "D", "E", ""))
# ggsave(sf_copstage, filename = "../figs/figS_copstage.png", width = 270, height = 70*2, units = "mm")
ggsave(sf_copstage, filename = "../figs/figS_copstage.svg", width = 270, height = 70*2, units = "mm")
# edit inf legend, move top row down
```

Now let's focus on just the infected copepods. Do the lines differ in survival rates?

```{r}
# fixed effects
m1_surv <- MCMCglmm(cop_dead_13dpe ~ cop_stage_checking + ib, 
                        random = ~cop_block,
                 family = "categorical",
                 data = dat_surv13_2,
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_surv, 
                 thin = thin_surv,
                 burnin = burnin_surv
                )

# gen x selection line
m2_surv <- MCMCglmm(cop_dead_13dpe ~ cop_stage_checking + ib + gen_line, 
                        random = ~cop_block,
                 family = "categorical",
                 data = dat_surv13_2,
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_surv, 
                 thin = thin_surv,
                 burnin = burnin_surv
                )

```

The effect of copepod stage and block in the infected-only model was comparable to the larger model (see previous figure). Inbred worms were not more likely to kill their copepod hosts.

```{r}
summary(m1_surv)
```

Adding generation and line does not reduce model deviance much.

```{r}
plot(mcmc.list(m1_surv$Deviance, m2_surv$Deviance), density = F)
```

Most of the 'line' parameters are not significant.

```{r}
summary(m2_surv)
```

```{r}
# manual prediction, correcting for set variance comp
c2 <- ((16 * sqrt(3))/(15 * pi))^2

# first model
post_sol1 <- m1_surv$Sol/sqrt(1 + c2 * m1_surv$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_surv$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_surv13_2$pred == "yes1") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_surv$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here1,
                 surv_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_surv1 <- px%>%
  pivot_longer(
    cols = surv_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(cop_stage_checking, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

# first model, inbreeding
post_sol1 <- m1_surv$Sol/sqrt(1 + c2 * m1_surv$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_surv$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_surv13_2$pred == "yesib") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_surv$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here_ib,
                 surv_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_survib <- px%>%
  pivot_longer(
    cols = surv_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(ib, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))


# second model
post_sol2 <- m2_surv$Sol/sqrt(1 + c2 * m2_surv$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_surv$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_surv13_2$pred == "yes2") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_surv$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here2,
                 surv_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_surv2 <- px%>%
  pivot_longer(
    cols = surv_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(gen, line, gen_line, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

```{r}
## Here is the main effect of copepod stage from the infected-only model. 

# dx_avg <- dat_surv13_2%>%
#   filter(is.na(pred))%>%
#   group_by(cop_stage_checking)%>%
#   summarise(surv_prop = sum(cop_dead_13dpe)/sum(!is.na(cop_dead_13dpe)),
#             n = n())
# 
# ggplot(pred_surv1, aes(x = cop_stage_checking, y = 1-fit)) +
#   geom_pointrange(aes(ymin = 1-lwr, ymax = 1-upr), shape = 1) +
#   geom_point(data = dx_avg, aes(y = 1-surv_prop), shape = 16, color = 'red') +
#   geom_text(data = dx_avg, aes(label = n, y = 0), vjust = 1) +
#   scale_y_continuous(limits = c(0,1)) +
#   labs(y = "survival probability") +
#   theme(panel.grid.major.x = element_blank(),
#         axis.title.x = element_blank())
```

Copepod survival did not depend on parasite inbreeding.

```{r}
ggplot(pred_survib, aes(x = ib, y = 1-fit)) +
  geom_ribbon(aes(ymin = 1-upr, ymax = 1-lwr), alpha = 0.2) +
  geom_line() +
  geom_rug(data = dat_surv13_2%>%filter(cop_dead_13dpe == 0)%>%slice_sample(prop=0.55), 
           aes(y = cop_dead_13dpe),
           sides = 't', alpha = 0.1, position = "jitter") +
  geom_rug(data = dat_surv13_2%>%filter(cop_dead_13dpe == 1)%>%slice_sample(prop=0.55),
           aes(y = cop_dead_13dpe),
           sides = 'b', alpha = 0.1, position = "jitter") +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Inbreeding coefficient", y = "Copepod survival rate")
```

This is the odds ratio associated with full-sib mating: 

```{r}
post_surv_noib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"cop_stage_checkingC2"])
post_surv_ib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"cop_stage_checkingC2"] + post_sol1[,'ib']*.25)

sx <- summary(
  post_surv_noib/
  post_surv_ib
)
sx
```
```{r}
sx <- round(sx$quantiles,2)
s_ann <- paste0("OR: ", sx[3], " [", sx[1], " - ", sx[5], "]")
```

The relationship may be easier to see without the data.


```{r}
sf_ib_e <- ggplot(pred_survib, aes(x = ib, y = 1-fit)) +
  geom_ribbon(aes(ymin = 1-upr, ymax = 1-lwr), alpha = 0.2) +
  geom_line() +
  labs(x = "Inbreeding coefficient", y = "Copepod survival rate 13 dpi") +
  annotate("text", label = s_ann, 
           x = 0,
           y = min(1-pred_survib%>%.$upr),
           hjust = 0)
sf_ib_e
```


Survival rates varied among generations of the experiment, but there were not clear difference between lines (the dashed line is the average survival of uninfected copepods). Also, the model estimates and raw proportions diverged noticeably, especially in the last generation, suggesting differences in survival among blocks might impact model means.

```{r}
dx_avg_csurv <- dat_surv13_2%>%
  filter(is.na(pred))%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            surv_prop = sum(cop_dead_13dpe)/sum(!is.na(cop_dead_13dpe))
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4d <- ggplot(pred_surv2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = 1-fit, color = line)) +
  annotate("rect", xmin = -0.5, xmax = 4.5,
           ymin = 1-pred_surv0%>%filter(cop_stage_checking == "C2", cop_inf == 0)%>%.$upr,
           ymax = 1-pred_surv0%>%filter(cop_stage_checking == "C2", cop_inf == 0)%>%.$lwr,
           alpha = 0.2) +
  geom_hline(yintercept = 1-pred_surv0%>%filter(cop_stage_checking == "C2", cop_inf == 0)%>%.$fit, 
             linetype = "dashed") +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = 1-upr, ymax = 1-lwr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg_csurv, 
             aes(y = 1-surv_prop),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg_csurv, 
            aes(label = n, y = min(1-dx_avg_csurv$surv_prop)),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  # scale_y_continuous(limits = c(min(1-pred_surv2$upr),1)) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Copepod survival rate 13 dpe",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4d
```

Indeed, survival was lower in generation 4 (and 2 to a lesser degree), which the model compensates for by estimating higher survival.

```{r}
ggplot(dat_surv13_2%>%
         filter(is.na(pred))%>%
         group_by(gen, cop_block)%>%
         summarise(surv_prop = 1-sum(cop_dead_13dpe,na.rm=T)/sum(!is.na(cop_dead_13dpe))),
       aes(x = cop_block, y = surv_prop, fill = factor(gen))) +
  geom_bar(stat = "identity") +
  labs(x = "Block", y = "Survival rate", fill = "Gen") +
  theme(axis.text.x = element_blank(),
        panel.grid.major.x = element_blank())
```

Furthermore, the proportion of C1s, the stage least likely to survive the experiment, were most abundant in the 2nd and 4th generations of the experiment. This is another reason why mean survival was 'corrected' to be higher in these generations.

```{r}
ggplot(dat_surv13_2%>%
         filter(is.na(pred))%>%
         group_by(gen, cop_block)%>%
         summarise(prop_c1 = sum(cop_stage_checking=="C1")/sum(!is.na(cop_stage_checking))),
       aes(x = cop_block, y = prop_c1, fill = factor(gen))) +
  geom_bar(stat = "identity") +
  labs(x = "Block", y = "Proportion of C1 copepods", fill = "Gen") +
  theme(axis.text.x = element_blank(),
        panel.grid.major.x = element_blank())
```

## Traits in fish

Let's turn our attention from the first host to the second host, the stickleback. 

### Fish infection rate

What impacts infection rates in sticklebacks? Sticklebacks were exposed at 14 dpi but in the penultimate generation they were exposed 16 dpi to avoid potential selection against slow developers that would not yet be infective. Moreover, in the final generation, fish were exposed at 12, 14, and 16 dpi to test whether selection impacted when parasites become infective. Thus, we consider exposure day in the models. We also consider initial fish size, fish sex, and tank effects on infection rates.

Here's the number of fish that were exposed in total:

```{r}
sum(dat$used_fish_inf, na.rm = T)
```

Fish were maintained together in tanks in groups of about 12 fish. After fish were dissected to check for infection, they were microsatellite typed to match up individuals with the copepods they had been exposed to. However, microsatellite matching failed in some cases, usually because fish had died during the experiment and DNA could not be extracted. Here is the number that were not matched:

```{r}
sum(dat$fish_and_copepod_matched == 2, na.rm = T)
```

Infection was not scored for any of these fish. After we exclude them, we can check how many fish were still not scored as uninfected/infected (55).

```{r}
dat_finf <- dat%>%
  filter(fish_and_copepod_matched != 2)

with(dat_finf, table(schisto_inf, useNA = 'always'))
```

These unscored fish died during the experiment. Many of them died shortly after exposure, such that infection by tiny worms could not be determined confidently. Others died later, but went unnoticed and were so decomposed that the infection rate could not be confidently determined.

```{r}
# filter(dat_finf, is.na(schisto_inf))
```

These fish can still be used in the model, particularly if the other predictors like fish size or sex impact infection rates. Five of these fish lacked data on initial size. Looking back at my notes, these fish died within days of being isolated for infection. Thus, they can be removed.

```{r}
filter(dat_finf, is.na(schisto_inf), is.na(fish_initial_bm_g))%>%
  .$fish_id
```

After removing these fish, all remaining fish had values for initial size and tank id, but they were often missing 'sex'. Here is the number of fish lacking values for 'sex':

```{r}
dat_finf <- dat%>%
  filter(fish_and_copepod_matched != 2, !is.na(fish_initial_bm_g))

sum(is.na(dat_finf$fish_sex))
# filter(dat_finf, is.na(tank_id))
# filter(dat_finf, is.na(fish_sex)) # these are fish that had initial data but lacked sex
```

Fish sex was scored during dissections. The fish that lacked 'sex' had died during the experiment and 'sex' was not confidently scored. Since we centered fish sex, we can simply impute a value of zero for these fish.

```{r}
dat_finf$fish_sex_cen[which(!is.na(dat_finf$fish_initial_bm_cen) & is.na(dat_finf$fish_sex))] <- 0
```

We are left with this many exposed fish:

```{r}
sum(dat_finf$used_fish_inf, na.rm = T)
```

We can break down the exposed fish into three groups: uninfected, infected, and unknown (not scored for infection). Here is that table:

```{r}
table(dat_finf$schisto_inf, useNA = 'always')
```

And the table expressed as proportions:

```{r}
round(prop.table(table(dat_finf$schisto_inf, useNA = 'always')), 4)
```


Now let's begin fitting models. We take the same approach as above, first checking nuisance variables before comparing selection lines. 

```{r}
# to visualize effect of length
pred_here3 <- data.frame(pred = "yes3", 
                         cop_block = unique(dat$cop_block)[3],
                         ib = 0,
                         gen_line = unique(dat_finf$gen_line)[1],
                         tank_id = unique(dat$tank_id)[3],
                         fish_initial_bm_cen = 
                           seq(min(dat_finf$fish_initial_bm_cen), 
                               max(dat_finf$fish_initial_bm_cen), 
                               length.out = 50),
                         fish_sex_cen = 0, 
                         fish_exp_on_cop_dpe = 14)
# to visualize effect of sex
pred_here4 <- data.frame(pred = "yes4", 
                         ib = 0,
                         cop_block = unique(dat$cop_block)[3],
                         tank_id = unique(dat$tank_id)[3],
                         gen_line = unique(dat_finf$gen_line)[1],
                         fish_initial_bm_cen = 0,
                         fish_sex_cen = c(-0.5, 0.5), 
                         fish_exp_on_cop_dpe = 14)
# to visualize effect of dpi
pred_here5 <- dat_finf%>%
  select(gen, line, gen_line, fish_exp_on_cop_dpe)%>%
  distinct()%>%
  mutate(pred = "yes5",
         ib = 0,
         cop_block = unique(dat$cop_block)[3],
         tank_id = unique(dat$tank_id)[3],
         fish_initial_bm_cen = 0,
         fish_sex_cen = 0)
                         
pred_finf <- bind_rows(pred_here3, pred_here4, pred_here5, pred_here_ib)%>%
  mutate(fish_initial_bm_g = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T))

dat_finf <- dat_finf%>%
  bind_rows(., pred_finf)%>%
  mutate(fish_exp_on_cop_dpe_fct = factor(fish_exp_on_cop_dpe),
         gen_line_dpe = paste(gen_line, as.character(fish_exp_on_cop_dpe), sep = "_")) # dpi as factor
```

There are two potential random effects: copepod block and tank id. Tank is nested within copepod block, since all fish in a tank were exposed at the same time as part of a given infection round. On the one hand, copepod block may capture 'noise' variation in copepod 'quality' from round to round. On the other hand, some tanks may exhibit higher or lower infections, due to random variation in social behavior, feeding, water flow rates, etc. Therefore, we fit models with both random effects to see which explains more variation in infection rate. The model includes the fixed predictors of initial fish mass, fish sex, and dpi in copepods.

```{r}
thin_finf <- 75
burnin_finf <- 1000
nit_finf <- thin_finf * target_post_dist_sample_size + burnin_finf

p2_bi <- list(R = list(V = 1, fix = 1),
              G = list(G1 = list(V = 1, nu = 0.002),
                       G2 = list(V = 1, nu = 0.002)))


# fixed effects
m0_finf_re <- MCMCglmm(schisto_inf ~ fish_initial_bm_cen + fish_sex_cen + fish_exp_on_cop_dpe_fct, 
                        random = ~cop_block + tank_id,
                 family = "categorical",
                 data = dat_finf,
                 prior = p2_bi,
                 verbose=F,
                 nitt = nit_finf, 
                 thin = thin_finf,
                 burnin = burnin_finf
                )

```

In this model, the variance for 'copepod block' was larger than for 'tank', even though there were far fewer 'blocks' than 'tanks'. Thus, we'll retain block as the lone random effect in the models. 

```{r}
summary(m0_finf_re)
```

In addition to the two models - (i) nuisance variables and (ii) generation x line - we need to test a third model. In the final generation of the experiment, fish were exposed to every line at three time points (12, 14, and 16 dpi in copepods). Since infection rates may depend on dpi and line (e.g. if fast developers are better at infection at early but not late time points), we need to fit an interaction term.

```{r}
# fixed effects
m1_finf <- MCMCglmm(schisto_inf ~ ib + fish_initial_bm_cen + fish_sex_cen + fish_exp_on_cop_dpe_fct, 
                        random = ~cop_block,
                 family = "categorical",
                 data = dat_finf%>%
                   mutate(fish_exp_on_cop_dpe_fct = fct_relevel(fish_exp_on_cop_dpe_fct, c("14", "12", "16"))),
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_finf, 
                 thin = thin_finf,
                 burnin = burnin_finf
                )

# gen x selection line
m2_finf <- MCMCglmm(schisto_inf ~ ib + fish_initial_bm_cen + fish_sex_cen + fish_exp_on_cop_dpe_fct + gen_line, 
                        random = ~cop_block,
                 family = "categorical",
                 data = dat_finf%>%
                   mutate(fish_exp_on_cop_dpe_fct = fct_relevel(fish_exp_on_cop_dpe_fct, c("14", "12", "16"))),
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_finf, 
                 thin = thin_finf,
                 burnin = burnin_finf
                )

# gen x selection line x dpi
m3_finf <- MCMCglmm(schisto_inf ~ ib + fish_initial_bm_cen + fish_sex_cen + gen_line_dpe, 
                        random = ~cop_block,
                 family = "categorical",
                 data = dat_finf%>%
                   mutate(fish_exp_on_cop_dpe_fct = fct_relevel(fish_exp_on_cop_dpe_fct, c("14", "12", "16"))),
                 prior = p1_bi,
                 verbose=FALSE,
                 nitt = nit_finf, 
                 thin = thin_finf,
                 burnin = burnin_finf
                )

```

The first model suggested that fish size has little effect on susceptibility, males were more susceptible than females, inbred worms were less infective, and that infection rates were lower at 12 dpi.

```{r}
summary(m1_finf)
```

Let's plot these effects.

```{r}
# manual prediction, correcting for set variance comp
c2 <- ((16 * sqrt(3))/(15 * pi))^2

# first model
post_sol1 <- m1_finf$Sol/sqrt(1 + c2 * m1_finf$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_finf$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_finf$pred %in% c("yes3", "yes4")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_finf$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(bind_rows(pred_here3, pred_here4),
                 finf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_finf1 <- px%>%
  pivot_longer(
    cols = finf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, fish_initial_bm_cen, fish_sex_cen, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
# first model, inbreeding
post_sol1 <- m1_finf$Sol/sqrt(1 + c2 * m1_finf$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_finf$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_finf$pred %in% c("yesib")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_finf$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(bind_rows(pred_here_ib),
                 finf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_finfib <- px%>%
  pivot_longer(
    cols = finf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(ib, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

Here is the initial size of fish that did and did not get infected with *S. solidus*.

```{r}
ggplot(dat_finf%>%filter(!is.na(schisto_inf)),
       aes(x = factor(schisto_inf), y = fish_initial_bm_g)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(alpha = 0.2) +
  scale_x_discrete(labels = c("uninfected", "infected")) +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
```

And here is the relationship predicted by the model. It is quite flat.

```{r}
dat_finf_fs_avg <- dat_finf%>%
  # mutate(ifw_cat = cut_interval(fish_initial_bm_g, n = 10))%>%
  mutate(ifw_cat = cut_width(fish_initial_bm_g, 0.08, center = 0))%>%
  group_by(ifw_cat)%>%
  summarize(n = n(), 
            finf = sum(schisto_inf, na.rm=T)/sum(!is.na(schisto_inf)))
dat_finf_fs_avg <- dat_finf_fs_avg%>%mutate(ifw = seq(0.08, 0.08*length(ifw_cat), by = 0.08))

sf_fs_a <- ggplot(pred_finf1%>%
         filter(pred == "yes3"),
       aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T),
           y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2) +
  geom_line() +
  geom_point(data = dat_finf_fs_avg, aes(x = ifw, y = finf, size = n)) +
  labs(x = "Initial fish mass (g)", y = "Fish infection rate")
sf_fs_a
```

Males were more likely to be infected than females. Here's the odds ratio for fish sex:

```{r}
# summary(exp(m1_finf$Sol[,'fish_sex_cen'] * -.5))
post_dist_m <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"fish_sex_cen"]*-0.5)
post_dist_f <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,"fish_sex_cen"]*0.5)
summary(post_dist_m/post_dist_f)
```

And the plot for fish sex (notice the y-axis is quite narrow):

```{r}
dx_avg <- dat_finf%>%
  filter(is.na(pred), !is.na(schisto_inf), fish_sex_cen != 0)%>%
  group_by(fish_sex_cen)%>%
  summarise(finf_prop = sum(schisto_inf)/sum(!is.na(schisto_inf)),
            n = n())


sf_sex_a <- ggplot(pred_finf1%>%
         filter(pred == "yes4"),
       aes(x = factor(fish_sex_cen), y = fit)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr), shape = 1) +
  geom_point(data = dx_avg, aes(y = finf_prop), shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n,
                y = pred_finf1%>%filter(pred == "yes4")%>%.$lwr%>%min()),
            vjust = 1,
            size = 2.5) +
  scale_x_discrete(labels = c("male", "female")) +
  labs(y = "Fish infection rate") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
sf_sex_a
# # difference much smaller looking with scale from 0 to 1
# ggplot(pred_finf1%>%
#          filter(pred == "yes4"),
#        aes(x = factor(fish_sex_cen), y = fit)) +
#   geom_pointrange(aes(ymin = lwr, ymax = upr), shape = 1) +
#   geom_point(data = dx_avg, aes(y = finf_prop), shape = 16) +
#   scale_y_continuous(limits = c(0,1)) +
#   scale_x_discrete(labels = c("male", "female")) +
#   labs(y = "Fish infection rate") +
#   theme(panel.grid.major.x = element_blank(),
#         axis.title.x = element_blank())
```

Inbred worms were less likely to infect fish.

```{r}
ggplot(pred_finfib, aes(x = ib, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2) +
  geom_line() +
  geom_rug(data = dat_finf%>%filter(schisto_inf == 0)%>%slice_sample(prop=0.55), 
           aes(y = schisto_inf),
           sides = 't', alpha = 0.1, position = "jitter") +
  geom_rug(data = dat_finf%>%filter(schisto_inf == 1)%>%slice_sample(prop=0.55),
           aes(y = schisto_inf),
           sides = 'b', alpha = 0.1, position = "jitter") +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Inbreeding coefficient", y = "Stickleback infection rate")
```

This is the predicted fish infection rate without inbreeding: 

```{r}
post_finf_noib <- boot::inv.logit(post_sol1[,"(Intercept)"])
posterior.mode(post_finf_noib)
```

And here is the rate with full-sib mating:

```{r}
post_finf_ib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,'ib']*.25)
posterior.mode(post_finf_ib)
```
Here is the odds ratio for fish infection rate associated with full-sib mating: 

```{r}
sx <- summary(
  post_finf_ib/
  post_finf_noib
)
sx
```
```{r}
sx <- round(sx$quantiles,2)
s_ann <- paste0("OR: ", sx[3], " [", sx[1], " - ", sx[5], "]")
```

```{r}
sf_ib_f <- ggplot(pred_finfib, aes(x = ib, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2) +
  geom_line() +
  labs(x = "Inbreeding coefficient", y = "Fish infection rate") +
  annotate("text", label = s_ann, 
           x = 0,
           y = pred_finfib%>%.$lwr%>%min(),
           hjust = 0)
sf_ib_f
```

So, we want to compare the selection lines holding sex and body size constant. Adding selection lines seems to improve the model (red line), but adding the interaction between dpi and line in the final generation may not be as important. However, the fish were only exposed at different times in the last generation, and some of this variation may have been explained by the 'dpi' term in the original model.

```{r}
plot(mcmc.list(m1_finf$Deviance, m2_finf$Deviance, m3_finf$Deviance), density = F)
```
```{r}
# library(lme4)
```
```{r}
# m2_finf_mer <- glmer(schisto_inf ~ fish_initial_bm_cen + fish_sex_cen + fish_exp_on_cop_dpe_fct + gen_line +
#                        (1| cop_block),
#                  family = "binomial",
#                  data = filter(dat_finf, !is.na(schisto_inf)))
# m3_finf_mer <- update(m2_finf_mer, . ~ . -gen_line + gen_line_dpe)
# anova(m2_finf_mer, m3_finf_mer) # not significant
```

Here are the results from the second model. Several of the 'line' terms are significant. Also, the variance attributed to block decreased substantially, such that it overlaps zero.

```{r}
summary(m2_finf)
# plot(m2_finf$VCV)
```

```{r}
# second model
post_sol2 <- m2_finf$Sol/sqrt(1 + c2 * m2_finf$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_finf$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_finf$pred %in% c("yes5")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_finf$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here5,
                 finf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_finf2 <- px%>%
  pivot_longer(
    cols = finf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, gen, line, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

# third model
post_sol3 <- m3_finf$Sol/sqrt(1 + c2 * m3_finf$VCV[, 'units']) # correction suggested in course notes
pdx <- m3_finf$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_finf$pred %in% c("yes5")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m3_finf$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol3[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here5%>%
                   mutate(gen_line_dpe = paste(gen_line, as.character(fish_exp_on_cop_dpe), sep = "_")),
                 finf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_finf3 <- px%>%
  pivot_longer(
    cols = finf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, gen, line, fish_exp_on_cop_dpe, gen_line_dpe, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

```
Here are infection rates across generations. They are variable. The lower infection rates in the slow line in the first two generations prompted the later exposure day in generation 3. Also, note the wide CIs in the final generation. This was expected because fish were exposed at 3 different time points. 

```{r}
dx_avg <- dat_finf%>%
  filter(is.na(pred), !is.na(schisto_inf))%>%
  group_by(gen, line, gen_line)%>%
  summarise(finf_prop = sum(schisto_inf)/sum(!is.na(schisto_inf)),
            n = n())%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4e <- ggplot(pred_finf2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = finf_prop),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(pred_finf2$lwr)),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_y_continuous(limits = c(min(pred_finf2$lwr), max(pred_finf2$upr))) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Stickleback infection rate",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4e
```

Thus, let's zoom in on generation 4 and split infection rate by dpi. Now, we see that the fast line was generally more infectious but especially early on (12 dpi). The slow line also seems to differ from the control most at this time point. This suggests that our selection protocol did produce worms that were more/less likely to infect fish when transmitted after less time in the copepod.

```{r}
dx_avg <- dat_finf%>%
  filter(is.na(pred), !is.na(schisto_inf))%>%
  filter(gen == 4)%>%
  group_by(gen, line, fish_exp_on_cop_dpe, gen_line_dpe)%>%
  summarise(finf_prop = sum(schisto_inf)/sum(!is.na(schisto_inf)),
            n = n())%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("fast", "control", "slow")))

dw <- 0.6
f3c <- ggplot(pred_finf3%>%
         filter(gen == 4)%>%
         mutate(line = factor(line, levels = c("fast", "control", "slow"))),
       aes(x = factor(fish_exp_on_cop_dpe), y = fit, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = finf_prop),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(pred_finf3$lwr)),
            position = position_dodge2(width = dw), 
            vjust = 1,
            size = 2) +
  scale_y_continuous(limits = c(min(pred_finf3$lwr), max(pred_finf3$upr))) +
  scale_color_manual(values = c("red", "black", "blue")) +
  labs(y = "Stickleback infection rate\nfinal generation",
       x = "Days post infection in copepods") +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f3c
```
```{r}
f3 <- cowplot::plot_grid(f3a + guides(color = guide_legend(override.aes = list(size = 0.2))) +
                           theme(legend.text = element_text(size = 7)),
                         f3b + guides(color = "none"),
                         f3c + guides(color = "none"), 
                         nrow = 1,
                         align = "hv",
                         labels = "AUTO")
# ggsave(f3, filename = "../figs/fig3_response.png", width = 270, height = 70, units = "mm")
ggsave(f3, filename = "../figs/fig3_response.svg", width = 270, height = 70, units = "mm")
```

Let's check the odds ratios in plot above, starting with 12 dpi.

```{r}
# get posterior predicteds for gen 4, day 12
post_dist_4ctrl12dpe <- boot::inv.logit(post_sol3[,"(Intercept)"] + post_sol3[,"gen_line_dpe4_control_12"])
post_dist_4fast12dpe <- boot::inv.logit(post_sol3[,"(Intercept)"] + post_sol3[,"gen_line_dpe4_fast_12"])
post_dist_4slow12dpe <- boot::inv.logit(post_sol3[,"(Intercept)"] + post_sol3[,"gen_line_dpe4_slow_12"])

# get posterior predicteds for gen 4, day 14
post_dist_4ctrl14dpe <- boot::inv.logit(post_sol3[,"(Intercept)"] + post_sol3[,"gen_line_dpe4_control_14"])
post_dist_4fast14dpe <- boot::inv.logit(post_sol3[,"(Intercept)"] + post_sol3[,"gen_line_dpe4_fast_14"])
post_dist_4slow14dpe <- boot::inv.logit(post_sol3[,"(Intercept)"] + post_sol3[,"gen_line_dpe4_slow_14"])

# odds ratios, day 12
odds_ctrl_vs_fast12 <- post_dist_4fast12dpe/post_dist_4ctrl12dpe
odds_ctrl_vs_slow12 <- post_dist_4slow12dpe/post_dist_4ctrl12dpe
odds_fast_vs_slow12 <- post_dist_4fast12dpe/post_dist_4slow12dpe

# odds ratios, day 14
odds_ctrl_vs_fast14 <- post_dist_4fast14dpe/post_dist_4ctrl14dpe
odds_ctrl_vs_slow14 <- post_dist_4slow14dpe/post_dist_4ctrl14dpe
odds_fast_vs_slow14 <- post_dist_4fast14dpe/post_dist_4slow14dpe
```

The odds ratio for fast vs control lines at 12 dpi was well above 1, but the CI overlapped 1, indicating the difference was not significant.

```{r}
summary(odds_ctrl_vs_fast12)
```

The odds ratio for slow vs control lines at 12 dpi also overlapped 1.

```{r}
summary(odds_ctrl_vs_slow12)
```

The odds ratio for fast vs slow line at 12 dpe was significant.

```{r}
summary(odds_fast_vs_slow12)
```

However, at 14 dpi, the same contrast was not quite significant.

```{r}
summary(odds_fast_vs_slow14)
```

Further, there was little difference between slow and control lines at 14 dpi.

```{r}
summary(odds_ctrl_vs_slow14)
```

### Fish survival

Most exposed fish survived until dissection (~80%). We can explore fish survival like we did for copepod survival. First, we check whether infection affects survival. Second, we can see if parasites from the different lines affect host survival differently. 

```{r}
with(filter(dat, used_fish_inf == 1), table(used_fish_inf, fish_surv, useNA = "ifany"))
```

Infection did seem to be associated with higher mortality - there were more infected fish among the dead.

```{r}
with(filter(dat, used_fish_inf == 1), table(fish_surv, schisto_inf, useNA = "ifany"))
```

Here is the same table but expressed in proportions - almost 3x as many dead ones were infected.

```{r}
round(prop.table(with(filter(dat, used_fish_inf == 1), table(fish_surv, schisto_inf, useNA = "ifany")), margin = 1), 2)
```

Let's fit a model, focusing just on fish for which infection was recorded. The model includes two random effects, copepod block and tank id, and the following fixed effects: fish size at exposure, fish sex, and infection. Further, we allowed the effect of infection to depend on initial size, e.g. infection may only kill small fish

```{r}
dat_fsurv <- dat%>%
  filter(used_fish_inf == 1, !is.na(fish_surv), !is.na(fish_initial_bm_cen))%>%
  mutate(fish_sex_cen = if_else(is.na(fish_sex_cen), 0, fish_sex_cen),
         schisto_inf_2 = if_else(is.na(schisto_inf), "unknown", 
                                 if_else(schisto_inf==1, "infected", "uninfected")))
dat_fsurv <- bind_rows( 
  dat_fsurv,
  mutate(pred_here3, schisto_inf_2 = "infected"),
  mutate(pred_here3, schisto_inf_2 = "uninfected"),
  mutate(pred_here4, schisto_inf_2 = "infected"),
  mutate(pred_here4, schisto_inf_2 = "uninfected")
  )
```

A preliminary model suggests that 'tank' is more important for determining survival than experimental copepod block, which makes sense. Further, big fish and uninfected fish had higher survival (and to a lesser degree, female fish). The size x infection interaction is also significant. 

```{r}
thin_fsurv <- 200
burnin_fsurv <- 1000
nit_fsurv <- thin_fsurv * target_post_dist_sample_size + burnin_fsurv


# compare RE effects
# m0_fsurv_re <- MCMCglmm(fish_surv ~ fish_sex_cen*schisto_inf_2 + fish_initial_bm_cen*schisto_inf_2, 
#                         random = ~cop_block + tank_id,
#                  family = "categorical",
#                  data = filter(dat_fsurv, schisto_inf_2 != "unknown"),
#                  prior = p2_bi,
#                  verbose=F,
#                  nitt = nit_fsurv, 
#                  thin = thin_fsurv,
#                  burnin = burnin_fsurv
#                 )

# fixed effects
m0_fsurv_re <- MCMCglmm(fish_surv ~ fish_sex_cen*schisto_inf_2 + fish_initial_bm_cen*schisto_inf_2, 
                        random = ~ tank_id,
                 family = "categorical",
                 data = filter(dat_fsurv, schisto_inf_2 != "unknown"),
                 prior = p1_bi,
                 verbose=F,
                 nitt = nit_fsurv, 
                 thin = thin_fsurv,
                 burnin = burnin_fsurv
                )
```
```{r}
summary(m0_fsurv_re)
```

Here is the difference between male and female fish, separated by infection. There is little difference between males and females. Rather, survival seems to be determined by fish size and infection.

```{r}
ggplot(dat_fsurv%>%
         filter(!is.na(fish_sex)),
       aes(x = factor(fish_sex), y = fish_initial_bm_g, color = factor(fish_surv))) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(position = position_jitterdodge(), alpha = 0.2) +
  facet_wrap(~schisto_inf_2) +
  scale_x_discrete(labels = c("male", "female")) +
  scale_color_discrete(labels = c("survived", "died")) +
  labs(y = "Fish mass at exposure (g)") +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank(),
        axis.title.x = element_blank())
```

We can also plot the model predictions.

```{r}
# manual prediction, correcting for set variance comp
# first model
post_sol1 <- m0_fsurv_re$Sol/sqrt(1 + c2 * m0_fsurv_re$VCV[, 'units']) # correction suggested in course notes
pdx <- m0_fsurv_re$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(filter(dat_fsurv, schisto_inf_2 != "unknown")%>%.$pred %in% c("yes3", "yes4")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m0_fsurv_re$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(
  filter(dat_fsurv, !is.na(pred)),
  # bind_rows( mutate(pred_here3, schisto_inf_2 = "infected"),
  #            mutate(pred_here3, schisto_inf_2 = "uninfected")
             # ),
  surv_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_fsurv0 <- px%>%
  pivot_longer(
    cols = surv_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, fish_sex_cen, schisto_inf_2, fish_initial_bm_cen, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

```{r}
dx_avg_fsurv <- dat_fsurv%>%
  filter(is.na(pred), !is.na(fish_sex_cen), fish_sex_cen != 0, schisto_inf_2 != "unknown")%>%
  group_by(fish_sex_cen, schisto_inf_2)%>%
  summarise(fsurv_prop = sum(fish_surv)/sum(!is.na(fish_surv)),
            n = n())%>%
  ungroup%>%
  mutate(schisto_inf_2 = factor(schisto_inf_2, levels = c("uninfected", "infected")))

sf_sex_b <- ggplot(pred_fsurv0%>%ungroup()%>%
                     filter(pred == "yes4")%>%
                     mutate(schisto_inf_2 = factor(schisto_inf_2, levels = c("uninfected", "infected")))
                   ,
       aes(x = factor(fish_sex_cen), y = 1-fit, 
           shape = schisto_inf_2,
           color = schisto_inf_2,
           fill = schisto_inf_2)) +
  geom_pointrange(
    aes(ymin = 1-upr, ymax = 1-lwr), 
    position = position_dodge2(width = dw),
    fill = "white"
    ) +
  geom_point(data = dx_avg_fsurv,
             aes(y = 1-fsurv_prop),
             position = position_dodge2(width = dw)
             ) +
  geom_text(data = dx_avg_fsurv,
            aes(label = n,
                y = 1 - max(dx_avg_fsurv$fsurv_prop)),
            vjust = 1,
            position = position_dodge2(width = dw+.2),
            size = 2.5) +
  scale_x_discrete(labels = c("male", "female")) +
  scale_shape_manual(values = c(22,21)) +
  scale_color_manual(values = c("goldenrod2", "black")) +
  scale_fill_manual(values = c("goldenrod2", "black")) +
  labs(y = "Fish survival rate") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank(),
        legend.title = element_blank(),
        legend.background = element_rect(color="black"),
        )
sf_sex_b
```

This plot visualizes the relationship between initial size, infection, and survival. Small infected fish died during the experiment, whereas size did not impact the mortality of uninfected fish. Also, many of the fish that died and could not be scored for infection were probably infected.

```{r}
ggplot(dat_fsurv, aes(x = schisto_inf_2, y = fish_initial_bm_g, color = factor(fish_surv))) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.6), alpha = 0.2) +
  scale_color_discrete(labels = c("survived", "died")) +
  labs(y = "Fish mass at exposure (g)") +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank(),
        axis.title.x = element_blank())
```

We can also plot the model predictions for this relationship. Clearly, small infected fish have lower survival, but large infected fish survive at a rate comparable to uninfected fish.

```{r}
dat_fsurv_fs_avg <- dat_fsurv%>%
  filter(!is.na(schisto_inf))%>%
  mutate(ifw_cat = cut_width(fish_initial_bm_g, 0.1, center = 0))%>%
  group_by(ifw_cat, schisto_inf_2)%>%
  summarize(n = n(), 
            fsurv = 1- sum(fish_surv, na.rm=T)/sum(!is.na(fish_surv)))%>%
  arrange(schisto_inf_2)%>%
  ungroup()
dat_fsurv_fs_avg <- dat_fsurv_fs_avg%>%
  mutate(ifw = rep(seq(0.1, 0.1*length(ifw_cat)/2, by = 0.1),2),
         schisto_inf_2 = fct_relevel(schisto_inf_2, c("uninfected", "infected")))

sf_fs_b <- ggplot(pred_fsurv0%>%ungroup()%>%
                    filter(pred == "yes3")%>%
                    mutate(schisto_inf_2 = fct_relevel(schisto_inf_2, c("uninfected", "infected"))), 
       aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T), 
           y = 1-fit, 
           fill = schisto_inf_2, 
           color = schisto_inf_2, 
           linetype = schisto_inf_2)) +
  geom_point(data = dat_fsurv_fs_avg, 
             aes(x = ifw, y = fsurv, size = n, shape = schisto_inf_2)) +
  geom_ribbon(aes(ymin = 1-upr, ymax = 1-lwr), alpha = 0.2, color = NA, 
              # fill = "black"
              ) +
  geom_line(size = 1, alpha = 0.75) +
  labs(x = "Initial fish mass (g)", y = "Fish survival rate") +
  scale_shape_manual(values = c(15,16)) +
  scale_linetype_manual(values = c("dashed", "solid")) +
  scale_color_manual(values = c("goldenrod2", "black")) +
  scale_fill_manual(values = c("goldenrod2", "black")) +
  guides(linetype = "none") +
  theme(legend.title = element_blank(),
        legend.position = c(0.75, 0.4),
        legend.background = element_rect(color = 'black'))
sf_fs_b
```

Let's now focus on just the infected fish. We fit two models, the first with the previous fixed effects (fish size and sex) and the second with the generation and selection line added.

```{r}
dat_fsurv2 <- dat_fsurv%>%
  filter(schisto_inf_2 == "infected", is.na(pred))%>%
  bind_rows(., 
            pred_here5%>%select(-fish_exp_on_cop_dpe)%>%distinct(),
            pred_here_ib)
```

```{r}
# fixed effects
m1_fsurv <- MCMCglmm(fish_surv ~ ib + fish_sex_cen + fish_initial_bm_cen, 
                        random = ~tank_id,
                 family = "categorical",
                 data = dat_fsurv2,
                 prior = p1_bi,
                 verbose=F,
                 nitt = nit_fsurv, 
                 thin = thin_fsurv,
                 burnin = burnin_fsurv
                )

# gen x line
m2_fsurv <- MCMCglmm(fish_surv ~ ib + fish_sex_cen + fish_initial_bm_cen + gen_line, 
                        random = ~tank_id,
                 family = "categorical",
                 data = dat_fsurv2,
                 prior = p1_bi,
                 verbose=F,
                 nitt = nit_fsurv, 
                 thin = thin_fsurv,
                 burnin = burnin_fsurv
                )
```

The effect of fish size is still significant but there is little effect of fish sex. And there is not a clear effect of inbreeding.

```{r}
summary(m1_fsurv)
```

```{r}
# manual prediction, correcting for set variance comp
# first model
post_sol1 <- m1_fsurv$Sol/sqrt(1 + c2 * m1_surv$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_fsurv$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_fsurv2$pred == "yesib") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_fsurv$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here_ib,
  surv_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_fsurvib <- px%>%
  pivot_longer(
    cols = surv_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(ib, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

```

Fish survival did not depend on parasite inbreeding.

```{r}
ggplot(pred_fsurvib, aes(x = ib, y = 1-fit)) +
  geom_ribbon(aes(ymin = 1-upr, ymax = 1-lwr), alpha = 0.2) +
  geom_line() +
  geom_rug(data = dat_fsurv2%>%filter(fish_surv == 0)%>%slice_sample(prop=0.55), 
           aes(y = cop_dead_13dpe),
           sides = 't', alpha = 0.1, position = "jitter") +
  geom_rug(data = dat_fsurv2%>%filter(fish_surv == 1)%>%slice_sample(prop=0.55),
           aes(y = cop_dead_13dpe),
           sides = 'b', alpha = 0.1, position = "jitter") +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Inbreeding coefficient", y = "Stickleback survival rate")
```

Here is the odds ratio for fish survival (outbred vs full-sib mating): 

```{r}
post_fsurv_noib <- boot::inv.logit(post_sol1[,"(Intercept)"])
post_fsurv_ib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,'ib']*.25)
sx <- summary(
  post_fsurv_noib/
  post_fsurv_ib
)
sx
```
```{r}
sx <- round(sx$quantiles,2)
s_ann <- paste0("OR: ", sx[3], " [", sx[1], " - ", sx[5], "]")
```

Here is the relationship without the data points.

```{r}
sf_ib_g <-  ggplot(pred_fsurvib, aes(x = ib, y = 1-fit)) +
  geom_ribbon(aes(ymin = 1-upr, ymax = 1-lwr), alpha = 0.2) +
  geom_line() +
  labs(x = "Inbreeding coefficient", y = "Fish survival rate") +
  annotate("text", label = s_ann, 
           x = 0,
           y = min(1-pred_fsurvib%>%.$upr),
           hjust = 0)
sf_ib_g
```


Adding the selection line does not have a clear impact on the model deviance, but some of the 'line' parameters were significant in the model.

```{r}
plot(mcmc.list(m1_fsurv$Deviance, m2_fsurv$Deviance), density = F)
```

```{r}
summary(m2_fsurv)
```

Let's plot the differences between selection lines.

```{r}
# second model
post_sol2 <- m2_fsurv$Sol/sqrt(1 + c2 * m2_fsurv$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_fsurv$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_fsurv2$pred %in% c("yes5")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_fsurv$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here5%>%select(-fish_exp_on_cop_dpe)%>%distinct(),
                 finf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_fsurv2 <- px%>%
  pivot_longer(
    cols = finf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, gen, line, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

Although fish survival varies, fish infected with the different lines do not consistently differ survival. The model-estimated survival rates in the base and first generations were higher that the observed rates, suggesting these groups may be characterized by small initial sizes.

```{r}
dx_avg <- dat_fsurv2%>%
  filter(is.na(pred), !is.na(fish_surv))%>%
  group_by(gen, line, gen_line)%>%
  summarise(fsurv_prop = sum(fish_surv)/sum(!is.na(fish_surv)),
            n = n())%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4f <- ggplot(pred_fsurv2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = 1-fit, color = line)) +
  annotate("rect", xmin = -0.5, xmax = 4.5,
           ymin = 1-pred_fsurv0%>%filter(schisto_inf_2 == "uninfected", between(x = fish_initial_bm_cen,-0.01, 0.01))%>%.$upr,
           ymax = 1-pred_fsurv0%>%filter(schisto_inf_2 == "uninfected", between(x = fish_initial_bm_cen,-0.01, 0.01))%>%.$lwr,
           alpha = 0.2) +
  geom_hline(yintercept = 1-pred_fsurv0%>%filter(schisto_inf_2 == "uninfected", between(x = fish_initial_bm_cen,-0.01, 0.01))%>%.$fit,
             linetype = "dashed") +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = 1-upr, ymax = 1-lwr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = 1-fsurv_prop),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = 1-max(pred_fsurv2$upr)),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Stickleback survival rate",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4f
```

Indeed they were, which is why the expected survival at an average fish mass was estimated to be higher by the model.

```{r}
ggplot(dat_fsurv2, aes(x = factor(gen), y = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T) )) +
  geom_boxplot(outlier.colour = NA) +
  geom_hline(yintercept = mean(dat$fish_initial_bm_g, na.rm = T), linetype = 'dotted') +
  geom_jitter(alpha = 0.3) +
  labs(x = "Generation", y = "Fish mass at exposure (g)") +
  theme(panel.grid.major.x = element_blank()
        )
```

Some fish were observed longer than others, as dissection times varied among generations. The survival models above did not account for this. One way to do this is with Cox regression, but survival was measured haphazardly, making survival times harder to interpret. An alternative is to take survival to a specific time, like the earliest dissection time (74 dpi). Thus, let's rerun the models but with a different survival metric: survival to 74 dpi.

This need not have a pronounced impact on the results. Only about 2% of the fish will change from "died" to "survived".

```{r}
dat_fsurv_75dpi <- dat_fsurv%>%
  mutate(fish_surv75 = if_else(age_dissection > 73 & fish_surv == 1, as.integer(0), fish_surv))

dat_fsurv_75dpi$fish_surv75[
  which(is.na(dat_fsurv_75dpi$age_dissection) & is.na(dat_fsurv_75dpi$pred))
] <- 1
```
```{r}
dat_fsurv_75dpi%>%
  filter(schisto_inf_2 != "unknown")%>%
  summarize(dead_before_dissection = sum(fish_surv, na.rm=T), 
            dead_before_earliest_dissection = sum(fish_surv75, na.rm=T),
            n = sum(!is.na(fish_surv)),
            # n2 = sum(!is.na(fish_surv75))
            )
```

```{r}
thin_fsurv <- 200
burnin_fsurv <- 1000
nit_fsurv <- thin_fsurv * target_post_dist_sample_size + burnin_fsurv

# fixed effects
m0_fsurv75 <- MCMCglmm(fish_surv75 ~ fish_sex_cen*schisto_inf_2 + fish_initial_bm_cen*schisto_inf_2, 
                        random = ~ tank_id,
                 family = "categorical",
                 data = filter(dat_fsurv_75dpi, schisto_inf_2 != "unknown"),
                 prior = p1_bi,
                 verbose=F,
                 nitt = nit_fsurv, 
                 thin = thin_fsurv,
                 burnin = burnin_fsurv
                )
```

There are still effects of infection and fish size.

```{r}
summary(m0_fsurv75)
```

```{r}
# manual prediction, correcting for set variance comp
# first model
post_sol1 <- m0_fsurv75$Sol/sqrt(1 + c2 * m0_fsurv75$VCV[, 'units']) # correction suggested in course notes
pdx <- m0_fsurv75$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(filter(dat_fsurv_75dpi, schisto_inf_2 != "unknown")%>%.$pred %in% c("yes3", "yes4")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m0_fsurv75$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(
  filter(dat_fsurv_75dpi, !is.na(pred)),
  # bind_rows( mutate(pred_here3, schisto_inf_2 = "infected"),
  #            mutate(pred_here3, schisto_inf_2 = "uninfected")
             # ),
  surv_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_fsurv0 <- px%>%
  pivot_longer(
    cols = surv_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, fish_sex_cen, schisto_inf_2, fish_initial_bm_cen, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

The difference between sexes is still small.

```{r}
dx_avg_fsurv <- dat_fsurv_75dpi%>%
  filter(is.na(pred), !is.na(fish_sex_cen), fish_sex_cen != 0, schisto_inf_2 != "unknown")%>%
  group_by(fish_sex_cen, schisto_inf_2)%>%
  summarise(fsurv_prop = sum(fish_surv75)/sum(!is.na(fish_surv75)),
            n = n())%>%
  ungroup%>%
  mutate(schisto_inf_2 = factor(schisto_inf_2, levels = c("uninfected", "infected")))

sf_sex_b <- ggplot(pred_fsurv0%>%ungroup()%>%
                     filter(pred == "yes4")%>%
                     mutate(schisto_inf_2 = factor(schisto_inf_2, levels = c("uninfected", "infected")))
                   ,
       aes(x = factor(fish_sex_cen), y = 1-fit, 
           shape = schisto_inf_2,
           color = schisto_inf_2,
           fill = schisto_inf_2)) +
  geom_pointrange(
    aes(ymin = 1-upr, ymax = 1-lwr), 
    position = position_dodge2(width = dw),
    fill = "white"
    ) +
  geom_point(data = dx_avg_fsurv,
             aes(y = 1-fsurv_prop),
             position = position_dodge2(width = dw)
             ) +
  geom_text(data = dx_avg_fsurv,
            aes(label = n,
                y = 1 - max(dx_avg_fsurv$fsurv_prop)),
            vjust = 1,
            position = position_dodge2(width = dw+.2),
            size = 2.5) +
  scale_x_discrete(labels = c("male", "female")) +
  scale_shape_manual(values = c(22,21)) +
  scale_color_manual(values = c("goldenrod2", "black")) +
  scale_fill_manual(values = c("goldenrod2", "black")) +
  labs(y = "Fish survival rate 74 dpe") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank(),
        legend.title = element_blank(),
        legend.background = element_rect(color="black"),
        )
sf_sex_b
```

And small infected fish still have lower survival, but large infected fish survive at a rate comparable to uninfected fish.

```{r}
dat_fsurv_fs_avg <- dat_fsurv_75dpi%>%
  filter(!is.na(schisto_inf))%>%
  mutate(ifw_cat = cut_width(fish_initial_bm_g, 0.1, center = 0))%>%
  group_by(ifw_cat, schisto_inf_2)%>%
  summarize(n = n(), 
            fsurv = 1- sum(fish_surv75, na.rm=T)/sum(!is.na(fish_surv75)))%>%
  arrange(schisto_inf_2)%>%
  ungroup()
dat_fsurv_fs_avg <- dat_fsurv_fs_avg%>%
  mutate(ifw = rep(seq(0.1, 0.1*length(ifw_cat)/2, by = 0.1),2),
         schisto_inf_2 = fct_relevel(schisto_inf_2, c("uninfected", "infected")))

sf_fs_b <- ggplot(pred_fsurv0%>%ungroup()%>%
                    filter(pred == "yes3")%>%
                    mutate(schisto_inf_2 = fct_relevel(schisto_inf_2, c("uninfected", "infected"))), 
       aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T), 
           y = 1-fit, 
           fill = schisto_inf_2, 
           color = schisto_inf_2, 
           linetype = schisto_inf_2)) +
  geom_point(data = dat_fsurv_fs_avg, 
             aes(x = ifw, y = fsurv, size = n, shape = schisto_inf_2)) +
  geom_ribbon(aes(ymin = 1-upr, ymax = 1-lwr), alpha = 0.2, color = NA, 
              # fill = "black"
              ) +
  geom_line(size = 1, alpha = 0.75) +
  labs(x = "Initial fish mass (g)", y = "Fish survival rate 74 dpe") +
  scale_shape_manual(values = c(15,16)) +
  scale_linetype_manual(values = c("dashed", "solid")) +
  scale_color_manual(values = c("goldenrod2", "black")) +
  scale_fill_manual(values = c("goldenrod2", "black")) +
  guides(linetype = "none") +
  theme(legend.title = element_blank(),
        legend.position = c(0.75, 0.4),
        legend.background = element_rect(color = 'black'))
sf_fs_b
```

Now we focus on just the infected fish. We fit two models, the first with the previous fixed effects (fish size and sex) and the second with the generation and selection line added.

```{r}
dat_fsurv2_75dpi <- dat_fsurv_75dpi%>%
  filter(schisto_inf_2 == "infected", is.na(pred))%>%
  bind_rows(., 
            pred_here5%>%select(-fish_exp_on_cop_dpe)%>%distinct(),
            pred_here_ib)
```

```{r}
# fixed effects
m1_fsurv75 <- MCMCglmm(fish_surv75 ~ ib + fish_sex_cen + fish_initial_bm_cen, 
                        random = ~tank_id,
                 family = "categorical",
                 data = dat_fsurv2_75dpi,
                 prior = p1_bi,
                 verbose=F,
                 nitt = nit_fsurv, 
                 thin = thin_fsurv,
                 burnin = burnin_fsurv
                )

# gen x line
m2_fsurv75 <- MCMCglmm(fish_surv75 ~ ib + fish_sex_cen + fish_initial_bm_cen + gen_line, 
                        random = ~tank_id,
                 family = "categorical",
                 data = dat_fsurv2_75dpi,
                 prior = p1_bi,
                 verbose=F,
                 nitt = nit_fsurv, 
                 thin = thin_fsurv,
                 burnin = burnin_fsurv
                )
```


```{r}
# manual prediction, correcting for set variance comp
# first model
post_sol1 <- m1_fsurv75$Sol/sqrt(1 + c2 * m1_fsurv75$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_fsurv75$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_fsurv2$pred == "yesib") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_fsurv75$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here_ib,
  surv_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_fsurvib <- px%>%
  pivot_longer(
    cols = surv_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(ib, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

```

Fish survival did not depend on parasite inbreeding. Here is the odds ratio for fish survival (outbred vs full-sib mating): 

```{r}
post_fsurv_noib <- boot::inv.logit(post_sol1[,"(Intercept)"])
post_fsurv_ib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,'ib']*.25)
sx <- summary(
  post_fsurv_noib/
  post_fsurv_ib
)
sx
```
```{r}
sx <- round(sx$quantiles,2)
s_ann <- paste0("OR: ", sx[3], " [", sx[1], " - ", sx[5], "]")
```

Here is the relationship without the data points.

```{r}
sf_ib_g <-  ggplot(pred_fsurvib, aes(x = ib, y = 1-fit)) +
  geom_ribbon(aes(ymin = 1-upr, ymax = 1-lwr), alpha = 0.2) +
  geom_line() +
  labs(x = "Inbreeding coefficient", y = "Fish survival rate 74 dpi") +
  annotate("text", label = s_ann, 
           x = 0,
           y = min(1-pred_fsurvib%>%.$upr),
           hjust = 0)
sf_ib_g
```


Adding the selection line does not have a clear impact on the model deviance.

```{r}
plot(mcmc.list(m1_fsurv75$Deviance, m2_fsurv75$Deviance), density = F)
```

```{r}
summary(m2_fsurv75)
```

Let's plot the differences between selection lines.

```{r}
# second model
post_sol2 <- m2_fsurv75$Sol/sqrt(1 + c2 * m2_fsurv75$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_fsurv75$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_fsurv2$pred %in% c("yes5")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_fsurv75$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here5%>%select(-fish_exp_on_cop_dpe)%>%distinct(),
                 finf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_fsurv2 <- px%>%
  pivot_longer(
    cols = finf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, gen, line, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

Although fish survival varies, fish infected with the different lines do not consistently differ survival. The model-estimated survival rates in the base and first generations were higher that the observed rates, suggesting these groups may be characterized by small initial sizes.

```{r}
dx_avg <- dat_fsurv2%>%
  filter(is.na(pred), !is.na(fish_surv))%>%
  group_by(gen, line, gen_line)%>%
  summarise(fsurv_prop = sum(fish_surv)/sum(!is.na(fish_surv)),
            n = n())%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4f <- ggplot(pred_fsurv2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = 1-fit, color = line)) +
  annotate("rect", xmin = -0.5, xmax = 4.5,
           ymin = 1-pred_fsurv0%>%filter(schisto_inf_2 == "uninfected", between(x = fish_initial_bm_cen,-0.01, 0.01))%>%.$upr,
           ymax = 1-pred_fsurv0%>%filter(schisto_inf_2 == "uninfected", between(x = fish_initial_bm_cen,-0.01, 0.01))%>%.$lwr,
           alpha = 0.2) +
  geom_hline(yintercept = 1-pred_fsurv0%>%filter(schisto_inf_2 == "uninfected", between(x = fish_initial_bm_cen,-0.01, 0.01))%>%.$fit,
             linetype = "dashed") +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = 1-upr, ymax = 1-lwr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = 1-fsurv_prop),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = 1-max(pred_fsurv2$upr)),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Stickleback survival rate 74 dpe",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4f
```

### Plerocercoid size

Next, we examine how much parasites grew in fish. For the majority of fish that were scored as infected, we measured parasite body mass. 

```{r}
with(dat, table(schisto_inf, !is.na(worm_bm_mg), useNA = "ifany"))
```

First, we can plot the distribution of parasite masses, both raw and log-transformed. There is a bit of a left-hand tail because of some very small worms from dead fish.

```{r}
cowplot::plot_grid( qplot(dat$worm_bm_mg, bins = 50) + labs(x = "Plerocercoid mass"),
                    qplot(dat$worm_bm_mg, bins = 50) + scale_x_log10() + labs(x = "Plerocercoid mass")
)
```

Here is the dependence of worm mass on dpi. Log-transforming parasite size may result in better residual behavior. This would be expected since size vs age is usually an exponential relationship.

```{r}
cowplot::plot_grid(
  ggplot(dat, aes(x = age_dissection, y = worm_bm_mg)) +
    geom_point(alpha = 0.5) + geom_smooth(se = F, method = lm) +
    labs(x = "DPI" , y = "Plercercoid mass"),
  ggplot(dat, aes(x = age_dissection, y = worm_bm_mg)) +
    geom_point(alpha = 0.5) + geom_smooth(se = F, method = lm) + scale_y_log10() +
    labs(x = "DPI" , y = "Plercercoid mass")
)
```

Here is the distribution of dissection ages for fish that did and did not survive until dissection. The dashed vertical line is the mean value for survivors - that's a good place to center the data.

```{r}
med_age_diss <- filter(dat, schisto_inf == 1, fish_surv == 0)%>%.$age_dissection%>%mean(na.rm = T)
med_age_diss <- round(med_age_diss, 0)
ggplot(filter(dat, schisto_inf == 1),
       aes(x = age_dissection, fill = factor(fish_surv))) +
  geom_histogram() +
  geom_vline(xintercept = med_age_diss,
             color = 'black', linetype = 'dashed') +
  scale_fill_discrete(labels = c("survived", "died")) +
  theme(legend.title = element_blank())
```

Let's start fitting models. The first model includes tank as a random effect and fish sex, fish size, and time to dissection as fixed effects. Then, we add generation and line. 

```{r}
dat_pler <- dat%>%
  filter(schisto_inf == 1, !is.na(age_dissection))%>%
  mutate(fish_sex_cen = if_else(is.na(fish_sex_cen), 0, fish_sex_cen),
         age_diss_cen = age_dissection - med_age_diss)

pred_pler_here <- bind_rows(
  mutate(pred_here3, age_diss_cen = 0), # effect of fish size
  mutate(pred_here4, age_diss_cen = 0), # effect of fish sex
  mutate(pred_here3, fish_initial_bm_cen = 0,
       pred = "yes6",
       ib = 0,
       age_diss_cen = seq(
         min(dat_pler%>%filter(!is.na(worm_bm_mg))%>%.$age_diss_cen, na.rm=T),
         max(dat_pler$age_diss_cen, na.rm=T),
         length.out = 50)
       ), # effect of age diss
  mutate(pred_here5, age_diss_cen = 0)%>%select(-fish_exp_on_cop_dpe)%>%distinct(), # effect of gen line
  mutate(pred_here_ib, age_diss_cen = 0)
)

dat_pler <- bind_rows(dat_pler, pred_pler_here)
```

```{r}
thin_pler <- 100
burnin_pler <- 1000
nit_pler <- thin_pler * target_post_dist_sample_size + burnin_pler

# fixed effects
m1_pler_log <- MCMCglmm(log(worm_bm_mg) ~ ib + fish_sex_cen + fish_initial_bm_cen + age_diss_cen, 
                 random = ~ tank_id,
                 family = "gaussian",
                 data = dat_pler,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_pler, 
                 thin = thin_pler,
                 burnin = burnin_pler
                )
m1_pler <- MCMCglmm(worm_bm_mg ~ ib + fish_sex_cen + fish_initial_bm_cen + age_diss_cen, 
                 random = ~ tank_id,
                 family = "gaussian",
                 data = dat_pler,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_pler, 
                 thin = thin_pler,
                 burnin = burnin_pler
                )
# gen x selection line
m2_pler_log <- MCMCglmm(log(worm_bm_mg) ~ ib + fish_sex_cen + fish_initial_bm_cen + age_diss_cen + gen_line, 
                 random = ~ tank_id,
                 family = "gaussian",
                 data = dat_pler,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_pler, 
                 thin = thin_pler,
                 burnin = burnin_pler
                )
m2_pler <- MCMCglmm(worm_bm_mg ~ ib + fish_sex_cen + fish_initial_bm_cen + age_diss_cen + gen_line, 
                 random = ~ tank_id,
                 family = "gaussian",
                 data = dat_pler,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_pler, 
                 thin = thin_pler,
                 burnin = burnin_pler
                )
```

First, we should decide whether or not to log transform plerocercoid size. Let's look at the residual plots from models with untransformed or log transformed plerocercoid size as the response variable. With untransformed data, there is too little residual variation when worms are small. By contrast, the problem is reversed by log transformation, with too little variation in large worms. Since most fish were dissected later in the experiment (and are thus more comparable), we prefer the models with untransformed body sizes.

```{r}
cowplot::plot_grid(
  qplot(y = dat_pler$worm_bm_mg - predict.MCMCglmm(m1_pler), x = predict.MCMCglmm(m1_pler)) +
    labs(x = "predicted", y = "residual", title = 'untransformed'),
  qplot(y = log(dat_pler$worm_bm_mg) - predict.MCMCglmm(m1_pler_log), x = predict.MCMCglmm(m1_pler_log)) +
    labs(x = "predicted", y = "residual", title = 'transformed')
)
```

The first model suggests that worms grow larger in bigger fish, particularly female fish. Inbred worms are smaller than completely outbred worms. There is also a significant tank effect. 

```{r}
summary(m1_pler)
```

These effects were also observed with log transformed plerocercoid size.

```{r}
summary(m1_pler_log)
```

Let's look at the marginal predictions from the models (i.e. excluding the random effect of block). 

```{r}
# predictions from log models
pred_pler1_log <- exp(predict.MCMCglmm(m1_pler_log, interval = "confidence"))
pred_pler1_log <- bind_cols(pred_pler_here%>%filter(pred != "yes5"),
                            data.frame(pred_pler1_log[which(dat_pler$pred %in% c("yes3", "yes4", "yes6", "yesib")),]))

pred_pler2_log <- exp(predict.MCMCglmm(m2_pler_log, interval = "confidence"))
pred_pler2_log <- bind_cols(pred_pler_here%>%filter(pred == "yes5"),
                        data.frame(pred_pler2_log[which(dat_pler$pred == "yes5"),]))

# predictions untransformed models
pred_pler1 <- predict.MCMCglmm(m1_pler, interval = "confidence")
pred_pler1 <- bind_cols(pred_pler_here%>%filter(pred != "yes5"),
                        data.frame(pred_pler1[which(dat_pler$pred %in% c("yes3", "yes4", "yes6", "yesib")),]))

pred_pler2 <- predict.MCMCglmm(m2_pler, interval = "confidence")
pred_pler2 <- bind_cols(pred_pler_here%>%filter(pred == "yes5"),
                        data.frame(pred_pler2[which(dat_pler$pred == "yes5"),]))
```

Here is the relationship between initial fish size and plerocercoid mass.

```{r}
ggplot(dat_pler, aes(x = fish_initial_bm_g, y = worm_bm_mg)) +
  geom_ribbon(data = pred_pler1%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_pler1%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit)
            ) +
  geom_point(alpha = 0.2) +
  labs(y = "Plerocercoid mass (mg)", x = "Initial fish mass (g)") 
```

The predicted relationship is not much different from the log model, though it expects more variability in bigger fish.

```{r}
sf_fs_c <- ggplot(dat_pler, aes(x = fish_initial_bm_g, y = worm_bm_mg)) +
  geom_point(size = 0.25) +
  geom_ribbon(data = pred_pler1_log%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_pler1_log%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit)
            ) +
  labs(y = "Plerocercoid mass (mg)", x = "Initial fish mass (g)") 
sf_fs_c
```

Here is the increase in plerocercoid size with time post infection.

```{r}
ggplot(dat_pler, aes(x = age_dissection, y = worm_bm_mg)) +
  geom_ribbon(data = pred_pler1%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_pler1%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = fit)
            ) +
  geom_point(alpha = 0.2) +
  labs(y = "Plerocercoid mass (mg)", x = "Days post infection") +
  coord_cartesian(xlim = c(35, max(dat_pler$age_dissection)))
```

The relationship looks much better in the log model.

```{r}
sf_age_a <- ggplot(dat_pler, aes(x = age_dissection, y = worm_bm_mg)) +
  geom_point(size = 0.25) +
  geom_ribbon(data = pred_pler1_log%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_pler1_log%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = fit)
            ) +
  labs(y = "Plerocercoid mass (mg)", x = "Days post exposure") +
  coord_cartesian(xlim = c(35, max(dat_pler$age_dissection)))
sf_age_a
```

There's only a small effect of sex, with worms growing slightly larger in females.

```{r}
ggplot(dat_pler%>%
         filter(fish_sex_cen != 0), 
       aes(x = factor(fish_sex_cen), y = worm_bm_mg)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(alpha = 0.2) +
  geom_pointrange(
    data = pred_pler1%>%filter(pred == "yes4"),
    aes(x = factor(fish_sex_cen),
        y = fit, ymin = lwr, ymax = upr), 
    size = 2) +
  scale_x_discrete(labels = c("male", "female")) +
  labs(y = "Plerocercoid mass (mg)") +
  theme(axis.title.x = element_blank())
```

This difference looks even smaller when plerocercoid size is log transformed.

```{r}
ggplot(dat_pler%>%
         filter(fish_sex_cen != 0), 
       aes(x = factor(fish_sex_cen), y = worm_bm_mg)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(alpha = 0.2) +
  geom_pointrange(
    data = pred_pler1_log%>%filter(pred == "yes4"),
    aes(x = factor(fish_sex_cen),
        y = fit, ymin = lwr, ymax = upr), 
    size = 2) +
  scale_x_discrete(labels = c("male", "female")) +
  labs(y = "Plerocercoid mass (mg)") +
  theme(axis.title.x = element_blank())
```

Here are the predicted means from the log model:

```{r}
dx_avg_pler_sex <- dat_pler%>%
  filter(is.na(pred), fish_sex_cen != 0, !is.na(fish_sex_cen))%>%
  group_by(fish_sex_cen)%>%
  summarise(n = n(),
            pler_mean = mean(worm_bm_mg, na.rm=T),
            )%>%
  ungroup()

sf_sex_c <- ggplot(dat_pler%>%
                     filter(fish_sex_cen != 0), 
       aes(x = factor(fish_sex_cen), y = worm_bm_mg)) +
  geom_pointrange(
    data = pred_pler1_log%>%filter(pred == "yes4"),
    aes(x = factor(fish_sex_cen),
        y = fit, ymin = lwr, ymax = upr), 
    shape = 1) +
  geom_point(data = dx_avg_pler_sex,
             aes(y = pler_mean),
             shape = 16) +
  geom_text(data = dx_avg_pler_sex, 
            aes(label = n,
                y = dx_avg_pler_sex%>%.$pler_mean%>%min()),
            vjust = 1,
            size = 2.5) +
  scale_x_discrete(labels = c("male", "female")) +
  labs(y = "Plerocercoid mass (mg)") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
sf_sex_c
```
This is the difference in plerocercoid mass (mg) between male and female fish, all else equal:

```{r}
summary(
  exp(m1_pler_log$Sol[,"(Intercept)"] + m1_pler_log$Sol[,"fish_sex_cen"] * 0.5) -
    exp(m1_pler_log$Sol[,"(Intercept)"] + m1_pler_log$Sol[,"fish_sex_cen"] * -0.5)
  )
```

All else equal, inbred worms tended to be smaller than outbred worms.

```{r}
ggplot(dat_pler, aes(x = ib, y = worm_bm_mg)) +
  geom_ribbon(data = pred_pler1_log%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_pler1_log%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit)
            ) +
  geom_point(alpha = 0.2) +
  labs(y = "Plerocercoid mass (mg)", x = "Inbreeding coefficient") 
```

In an average fish, for an average dissection time, an outbred worm is expected to weigh this much:

```{r}
post_pler_noib <- exp(m1_pler_log$Sol[,"(Intercept)"])
posterior.mode(post_pler_noib)
```

A worm from full-sib breeding is expected to weigh this much:

```{r}
post_pler_ib <- exp(m1_pler_log$Sol[,"(Intercept)"] + m1_pler_log$Sol[,'ib']*.25)
posterior.mode(post_pler_ib)
```

Thus, full-sib mating decreases plerocercoid size by this percent: 

```{r}
sx <- summary(100*(post_pler_noib - post_pler_ib)/post_pler_noib)
sx
```
```{r}
sx <- round(sx$quantiles,1)
s_ann <- paste0("PD: ", sx[3], "% [", sx[1], " - ", sx[5], "]")
```

Here is the trend without the points:

```{r}
sf_ib_h <- ggplot(dat_pler, aes(x = ib, y = worm_bm_mg)) +
  geom_ribbon(data = pred_pler1_log%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_pler1_log%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit)
            ) +
  # geom_point(alpha = 0.2) +
  labs(y = "Plerocercoid mass (mg)", x = "Inbreeding coefficient") +
  annotate("text", label = s_ann, 
           x = 0,
           y = pred_pler1_log%>%filter(pred == "yesib")%>%.$lwr%>%min(),
           hjust = 0)
sf_ib_h
```


Adding the selection line to the model does not seem to be much of an improvement.

```{r}
plot(mcmc.list(m1_pler$Deviance, m2_pler$Deviance), density = F)
```

Here are the parameters of the model.

```{r}
summary(m2_pler)
```

Here are the model predictions for plerocercoid size across generations. 

```{r}
dx_avg <- dat_pler%>%
  filter(is.na(pred))%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            pler_mean = mean(worm_bm_mg, na.rm=T),
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
ggplot(pred_pler2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = pler_mean),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(dx_avg$pler_mean)),
            position = position_dodge2(width = dw), 
            vjust = 1,
            size = 3) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Plerocercoid mass (mg)",
       x = "Generation") +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
```

And log transformed...

```{r}
dx_avg <- dat_pler%>%
  filter(is.na(pred), fish_surv == 0)%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            pler_mean = mean(worm_bm_mg, na.rm=T),
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4g <- ggplot(pred_pler2_log%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = pler_mean),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(pred_pler2_log$lwr)),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Plerocercoid mass (mg)",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4g
```

The reason that observed means and model estimates differed across generations is that covariate values differed from one generation to the next. For example, in the generation 1, where estimated means were higher than observed ones, fish were smaller and dissected earlier.

```{r}
cowplot::plot_grid(

  ggplot(dat_pler%>%
         filter(!is.na(gen)),
       aes(x = factor(gen), y = age_dissection )) +
  geom_boxplot(outlier.colour = NA) +
  geom_hline(yintercept = med_age_diss, linetype = 'dotted') +
  geom_jitter(alpha = 0.3) +
  labs(x = "Generation", y = "Days post infection") +
  theme(panel.grid.major.x = element_blank()),
  
  ggplot(dat_pler%>%
         filter(!is.na(gen)),
       aes(x = factor(gen), y = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T) )) +
  geom_boxplot(outlier.colour = NA) +
  geom_hline(yintercept = mean(dat$fish_initial_bm_g, na.rm = T), linetype = 'dotted') +
  geom_jitter(alpha = 0.3) +
  labs(x = "Generation", y = "Fish mass at exposure (g)") +
  theme(panel.grid.major.x = element_blank()),

  ncol = 1
)
```

### Fish liver size

Liver mass was measured in dissected fish, so all fish that were scored for infection also had a liver mass measurement. Having a large liver, relative to body mass, is considered a sign of good energetic condition.

```{r}
# with(dat, table(fish_surv, !is.na(fish_liver_mg))) # essentially all liver measures from surviving fish

# with(dat, table(schisto_inf, !is.na(fish_liver_mg), useNA = 'ifany')) # all fish with liver measures scored for infection
```

Here is the log-log plot of initial fish size versus liver mass. It is linear, so we should log-transform both variables in the model. Also, some of the residual variation here is probably due to differences in dissection age.

```{r}
ggplot(dat%>%
         filter(!is.na(schisto_inf)),
       aes(x = fish_initial_bm_g, y = fish_liver_mg, color = factor(schisto_inf))) +
  geom_point(alpha = 0.5) + geom_smooth() + 
  scale_y_log10() + scale_x_log10() +
  labs(x = "Fish mass at exposure (g)", y = "Liver mass at dissection (mg)") +
  scale_color_discrete(labels = c("uninfected", "infected")) +
  theme(legend.title = element_blank())
```

When we plot dpi versus liver mass, we see a positive relationship, though it is less clear than the relationship with body size .

```{r}
ggplot(dat%>%
         filter(!is.na(schisto_inf), fish_surv == 0),
       aes(x = age_dissection, y = fish_liver_mg, color = factor(schisto_inf))) +
  geom_point(alpha = 0.5) + geom_smooth() + 
  scale_y_log10() +
  labs(x = "Days post infection", y = "Liver mass at dissection (mg)") +
  scale_color_discrete(labels = c("uninfected", "infected")) +
  theme(legend.title = element_blank())
```

Let's first model the differences between infected and uninfected fish. We consider tank as a random effect and fish initial size, sex, and dpi as fixed effects. Further, all these fixed effects were allowed to interact with infection status.

```{r}
dat_liver <- dat%>%
  filter(!is.na(fish_liver_mg), !is.na(age_dissection))%>%
  mutate(log_fish_initial_bm = log(fish_initial_bm_g))%>%
  mutate(fish_sex_cen = if_else(is.na(fish_sex_cen), 0, fish_sex_cen),
         age_diss_cen = age_dissection - med_age_diss,
         log_fish_initial_bm_cen = log_fish_initial_bm - log(mean(dat$fish_initial_bm_g, na.rm = T)))

# contrasting inf vs uninf, all else equal
pred_here_i <- mutate(pred_here4, ib = 0, age_diss_cen = 0, log_fish_initial_bm_cen = 0, fish_sex_cen = 0,
                      schisto_inf = c(0,1), pred = "yesi")
# predicting liver vs siZe relationship
pred_here3_i <- pred_here3%>%
  mutate(schisto_inf = 1,
         age_diss_cen = 0, ib = 0,
         log_fish_initial_bm_cen = log(fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T)) - 
           log(mean(dat$fish_initial_bm_g, na.rm = T)))
pred_here3_u <- mutate(pred_here3_i, schisto_inf = 0)


# constrasting sexes, infected vs uninfected
pred_here4_i <- mutate(pred_here4, ib = 0, age_diss_cen = 0, log_fish_initial_bm_cen = 0, schisto_inf = 1) 
pred_here4_u <- mutate(pred_here4_i, schisto_inf = 0)

# predicting liver vs age relationship
pred_here6_i <- mutate(pred_here3, fish_initial_bm_cen = 0, log_fish_initial_bm_cen = 0,
                       pred = "yes6",
                       ib = 0,
                       schisto_inf = 1, 
                       age_diss_cen = seq(
                         min(dat_liver$age_diss_cen, na.rm=T),
                         max(dat_liver$age_diss_cen, na.rm=T),
                         length.out = 50)
)
pred_here6_u <- mutate(pred_here6_i, schisto_inf = 0)

pred_liver_here <- bind_rows(
  pred_here_i,
  pred_here3_i, pred_here3_u,
  pred_here4_i, pred_here4_u,
  pred_here6_i, pred_here6_u,
  mutate(pred_here5, age_diss_cen = 0, log_fish_initial_bm_cen = 0, schisto_inf = 1)%>%
    select(-fish_exp_on_cop_dpe)%>%distinct(),
  mutate(pred_here_ib, age_diss_cen = 0, schisto_inf = 1)
)

dat_liver <- bind_rows(dat_liver, pred_liver_here)
```

```{r}
thin_liver <- 100
burnin_liver <- 1000
nit_liver <- thin_liver * target_post_dist_sample_size + burnin_liver

# inf vs uninfected effects
m0_liver <- MCMCglmm(
  log(fish_liver_mg) ~ schisto_inf*age_diss_cen + schisto_inf*fish_sex_cen + schisto_inf*log_fish_initial_bm_cen, 
  random = ~ tank_id,
  family = "gaussian",
  data = dat_liver,
  prior = p1_g,
  verbose=FALSE,
  nitt = nit_liver, 
  thin = thin_liver,
  burnin = burnin_liver
  )

```

The model suggests bigger, older, female fish that are uninfected have the biggest livers. However, there are significant interactions with infection, which are explored by plotting. Also, the model suggests a significant tank effect.

```{r}
summary(m0_liver)
```

```{r}
# predictions from log models 
pred_liver0 <- exp(predict.MCMCglmm(m0_liver, interval = "confidence"))
pred_liver0 <- bind_cols(pred_liver_here%>%filter(pred != "yes5"),
                         data.frame(pred_liver0[which(dat_liver$pred %in% c("yesi", "yes3", "yes4", "yes6", "yesib")),]))
```

Here is the predicted difference in liver mass between uninfected and infected fish (holding, size, sex, and age constant). It is almost twice as large in uninfected fish.

```{r}
pred_liver0%>%
  filter(pred == "yesi")%>%
  mutate(infected = if_else(schisto_inf == 0, "uninfected", "infected"))%>%
  select(infected, fit, lwr, upr)
```

Here is the effect size expressed in percent change (as both variables were log transformed):

```{r}
summary(exp(m0_liver$Sol[,"schisto_inf"]*-1) - 1)
```

Bigger fish have bigger livers, regardless of infection. But small, infected fish might have relatively small livers compared to small, uninfected fish.

```{r}
sf_fs_d <- ggplot(dat_liver,
       aes(x = fish_initial_bm_g, y = fish_liver_mg, 
           shape = factor(schisto_inf),
           fill = factor(schisto_inf),
           color = factor(schisto_inf))) +
  geom_point(size = 0.25) + 
  geom_ribbon(data = pred_liver0%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2, color = NA
              ) +
  geom_line(data = pred_liver0%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit,
                  linetype = factor(schisto_inf)
                  )
            ) +
  scale_y_log10() +
  # scale_x_log10() +
  labs(x = "Fish mass at exposure (g)", y = "Fish liver mass (mg)") +
  scale_shape_manual(values = c(15,16), labels = c("uninfected", "infected")) +
  scale_linetype_manual(values = c("dashed", "solid"), labels = c("uninfected", "infected")) +
  scale_color_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  scale_fill_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  theme(legend.title = element_blank())
# sf_fs_d
```

Although liver size did not vary strongly with days pi, there was a tendency for liver mass to increase in uninfected fish but decrease in infected fish, perhaps reflecting worsening condition as worms grew larger.

```{r}
sf_age_b <- ggplot(dat_liver,
       aes(x = age_dissection, y = fish_liver_mg, 
           shape = factor(schisto_inf),
           color = factor(schisto_inf))) +
  geom_point(size = 0.25) + 
  geom_ribbon(data = pred_liver0%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = fit, ymin = lwr, ymax = upr,
                  fill = factor(schisto_inf)), 
              alpha = 0.2, color = NA) +
  geom_line(data = pred_liver0%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = fit,
                  linetype = factor(schisto_inf)
                  )
            ) +
  scale_y_log10() +
  labs(x = "Days post exposure", y = "Fish liver mass (mg)") +
  scale_shape_manual(values = c(15,16), labels = c("uninfected", "infected")) +
  scale_linetype_manual(values = c("dashed", "solid"), labels = c("uninfected", "infected")) +
  scale_color_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  scale_fill_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  theme(legend.title = element_blank())
sf_age_b
```

Female fish tended to have slightly larger livers, regardless of infection.

```{r}
ggplot(dat_liver%>%
         filter(fish_sex_cen != 0), 
       aes(x = factor(fish_sex_cen), y = fish_liver_mg, color = factor(schisto_inf))) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(position = position_jitterdodge(), alpha = 0.2) +
  geom_pointrange(
    data = pred_liver0%>%filter(pred == "yes4"),
    aes(x = factor(fish_sex_cen),
        y = fit, ymin = lwr, ymax = upr), 
    size = 1,
    fill = "black",
    position = position_dodge(width = 0.75)) +
  scale_y_log10() +
  scale_x_discrete(labels = c("male", "female")) +
  scale_color_discrete(labels = c("uninfected", "infected")) +
  labs(y = "Stickleback liver mass (mg)") +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
```

This can be seen clearer when we do not plot the raw data, just the model means. The difference between sexes was a bit more pronounced in uninfected fish.

```{r}
dx_avg <- dat_liver%>%
  filter(is.na(pred), !is.na(fish_sex_cen), fish_sex_cen != 0)%>%
  group_by(fish_sex_cen, schisto_inf)%>%
  summarise(
    liver_mean = exp(mean(log(fish_liver_mg), na.rm=T)),
    n = n())%>%
  ungroup()

sf_sex_d <- ggplot(pred_liver0%>%filter(pred == "yes4"), 
       aes(x = factor(fish_sex_cen), 
           y = fit,
           color = factor(schisto_inf),
           shape = factor(schisto_inf),
           fill = factor(schisto_inf))
       ) +
  geom_pointrange(
    aes(ymin = lwr, ymax = upr), 
    position = position_dodge(width = dw),
    fill = "white") +
  geom_point(data = dx_avg,
             aes(y = liver_mean),
             position = position_dodge2(width = dw)
             ) +
  geom_text(data = dx_avg,
            aes(label = n,
                y = pred_liver0%>%filter(pred == "yes4")%>%.$lwr%>%min()),
            vjust = 1,
            position = position_dodge2(width = dw+.2),
            size = 2.5) +
  scale_x_discrete(labels = c("male", "female")) +
  scale_shape_manual(values = c(22,21), labels = c("uninfected", "infected")) +
  scale_color_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  scale_fill_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  labs(y = "Fish liver mass (mg)") +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        axis.title.x = element_blank(),
        legend.background = element_rect(color="black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0,1))
sf_sex_d
```

Now let's focus on just the infected fish. Does liver mass differ among our selection lines?

```{r}
dat_liver2 <- dat_liver%>%filter(schisto_inf == 1)
```

```{r}
# just fixed effects
m1_liver <- MCMCglmm(
  log(fish_liver_mg) ~ ib + age_diss_cen + fish_sex_cen + log_fish_initial_bm_cen, 
  random = ~ tank_id,
  family = "gaussian",
  data = dat_liver2,
  prior = p1_g,
  verbose=FALSE,
  nitt = nit_liver, 
  thin = thin_liver,
  burnin = burnin_liver
  )

# selection line effects
m2_liver <- MCMCglmm(
  log(fish_liver_mg) ~ ib + age_diss_cen + fish_sex_cen + log_fish_initial_bm_cen + gen_line, 
  random = ~ tank_id,
  family = "gaussian",
  data = dat_liver2,
  prior = p1_g,
  verbose=FALSE,
  nitt = nit_liver, 
  thin = thin_liver,
  burnin = burnin_liver
  )

# relationship between worm size and fish condition
m3_liver <- MCMCglmm(
  log(fish_liver_mg) ~ ib + age_diss_cen + fish_sex_cen + log_fish_initial_bm_cen + gen_line + worm_bm_mg, 
  random = ~ tank_id,
  family = "gaussian",
  data = dat_liver2%>%filter(is.na(pred), !is.na(worm_bm_mg)),
  prior = p1_g,
  verbose=FALSE,
  nitt = nit_liver, 
  thin = thin_liver,
  burnin = burnin_liver
  )
```

The effects of tank, fish size, sex, and age were similar in the infected-only model, so we do not reproduce the plots again. Fish infected with inbred worms tended to have larger livers.

```{r}
summary(m1_liver)
```

```{r}
# predictions from log models 
pred_liverib <- exp(predict.MCMCglmm(m1_liver, interval = "confidence"))
pred_liverib <- bind_cols(pred_liver_here%>%filter(pred == "yesib"),
                         data.frame(pred_liverib[which(dat_liver2$pred == "yesib"),]))
```

All else equal, fish infected with inbred worms tended to have larger livers.

```{r}
ggplot(dat_liver2, aes(x = ib, y = fish_liver_mg)) +
  geom_ribbon(data = pred_liverib%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_liverib%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit)
            ) +
  geom_point(alpha = 0.2) +
  labs(y = "Stickleback liver mass (mg)", x = "Inbreeding coefficient") 
```

Here is the percent increase in liver mass associated with full-sib mating:

```{r}
post_liver_noib <- exp(m1_liver$Sol[,"(Intercept)"])
post_liver_ib <- exp(m1_liver$Sol[,"(Intercept)"] + m1_liver$Sol[,'ib']*.25)
sx <- summary(100*(post_liver_ib - post_liver_noib)/post_liver_noib)
sx
```
```{r}
sx <- round(sx$quantiles,1)
s_ann <- paste0("PI: ", sx[3], "% [", sx[1], " - ", sx[5], "]")
```

Here is the trend without the points

```{r}
sf_ib_i <- ggplot(dat_liver2, aes(x = ib, y = fish_liver_mg)) +
  geom_ribbon(data = pred_liverib%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_liverib%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit)
            ) +
  labs(y = "Fish liver mass (mg)", x = "Inbreeding coefficient") +
  annotate("text", label = s_ann, 
           x = pred_liverib%>%filter(pred == "yesib")%>%.$ib%>%max(),
           y = pred_liverib%>%filter(pred == "yesib")%>%.$lwr%>%min(),
           hjust = 1)
sf_ib_i
```

Adding the selection line to the infected-only model does not seem to reduce the deviance much.

```{r}
plot(mcmc.list(m1_liver$Deviance, m2_liver$Deviance), density = F)
```

Most of the line parameters were not significant, though a few were, so we plot the predictions.

```{r}
summary(m2_liver)
```

```{r}
# predictions from log models 
pred_liver2 <- exp(predict.MCMCglmm(m2_liver, interval = "confidence"))
pred_liver2 <- bind_cols(pred_liver_here%>%filter(pred == "yes5"),
                         data.frame(pred_liver2[which(dat_liver2$pred == "yes5"),]))
```

There are not clear differences in liver mass between lines. However, the fish in the final generation tended to have larger livers, on par with those in uninfected fish (the horizontal dashed line). Worm size was also larger in these fish, suggesting the fish used for this generation just tended to be in better condition.

```{r}
dx_avg_liv <- dat_liver2%>%
  filter(is.na(pred))%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            liver_mean = exp(mean(log(fish_liver_mg), na.rm=T)),
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4h <- ggplot(pred_liver2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit, color = line)) +
  annotate("rect", xmin = -0.5, xmax = 4.5,
           ymin = pred_liver0%>%filter(pred == "yesi", schisto_inf == 0)%>%.$lwr,
           ymax = pred_liver0%>%filter(pred == "yesi", schisto_inf == 0)%>%.$upr,
           alpha = 0.2) +
  geom_hline(yintercept = exp(posterior.mode(m0_liver$Sol[,"(Intercept)"])), # avg liver in uninfected
             linetype = "dashed") +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg_liv, 
             aes(y = liver_mean),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg_liv, 
            aes(label = n, y = min(dx_avg_liv$liver_mean)),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_y_log10() +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Stickleback liver mass (mg)",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4h
```
```{r}
pred_liver0%>%filter(pred == "yesi", schisto_inf == 0)
```

We may think that bigger worms would be worse for host condition (smaller livers), but when we add worm size into the model, we find a positive relationship.

```{r}
summary(m3_liver)
```

We can see this by plotting residual liver size (adjusted for fish size, sex, age) vs worm mass. Worms grow larger in hosts that exhibit better condition.

```{r}
ggplot(dat_liver2, aes(worm_bm_mg, log(fish_liver_mg) - log(pred_liver2$fit))) +
  geom_point(alpha = 0.5) + geom_smooth(se = F) +
  labs(x = "Plerocercoid mass (mg)", y = "Residual liver size")
```

### Fish growth

Another way to judge infection's impact on fish, and whether this differs between selection lines, is to examine fish growth. One could calculate fish growth directly (final - initial size) or model final size as response and initial size as a covariate (similar to above for liver mass). The plot of initial vs final mass is rather linear without log transformation (unlike for liver mass) suggesting fish did not grow enough in the 2-3 month infection to exhibit an exponential relationship.

```{r}
ggplot(dat%>%
         filter(!is.na(schisto_inf)), 
       aes(fish_initial_bm_g, fish_final_bm_g_noworm, color = factor(schisto_inf))) +
  geom_point(alpha = 0.2) + geom_smooth() +
  scale_color_discrete(labels = c("uninfected", "infected")) +
  theme(legend.title = element_blank())
```

This above relationship might be easier to model than pure growth (final - initial size). The plot of growth vs initial size looks less linear with more heterogeneous variance. Still, it shows that bigger fish added more mass than smaller fish, as expected.

```{r}
ggplot(dat%>%
         filter(!is.na(schisto_inf)), 
       aes(fish_initial_bm_g, fish_final_bm_g_noworm - fish_initial_bm_g, color = factor(schisto_inf))) +
  geom_point(alpha = 0.2) + geom_smooth()  +
  labs(y = "growth (final - initial g)") +
  scale_color_discrete(labels = c("uninfected", "infected")) +
  theme(legend.title = element_blank())
```

To compare infected and uninfected fish, we can use the same model as for liver mass, but this time without log transforming initial fish size. We test how final size (and thus growth) depends on initial size, days post infection, sex, and their interactions with infection.

```{r}
dat_fgrow <- dat%>%
  filter(!is.na(fish_final_bm_g_noworm), !is.na(age_dissection), !is.na(schisto_inf))%>%
  mutate(log_fish_initial_bm = log(fish_initial_bm_g))%>%
  mutate(fish_sex_cen = if_else(is.na(fish_sex_cen), 0, fish_sex_cen),
         age_diss_cen = age_dissection - med_age_diss,
         log_fish_initial_bm_cen = log_fish_initial_bm - log(mean(dat$fish_initial_bm_g, na.rm = T)))


pred_here6_i <- mutate(pred_here3, fish_initial_bm_cen = 0, log_fish_initial_bm_cen = 0,
                       pred = "yes6",
                       schisto_inf = 1, 
                       age_diss_cen = seq(
                         min(dat_fgrow$age_diss_cen, na.rm=T),
                         max(dat_fgrow$age_diss_cen, na.rm=T),
                         length.out = 50)
)
pred_here6_u <- mutate(pred_here6_i, schisto_inf = 0)

pred_fgrow_here <- bind_rows(
  pred_here_i,
  pred_here3_i, pred_here3_u,
  pred_here4_i, pred_here4_u,
  pred_here6_i, pred_here6_u,
  mutate(pred_here5, age_diss_cen = 0, log_fish_initial_bm_cen = 0, schisto_inf = 1)%>%
    select(-fish_exp_on_cop_dpe)%>%distinct(),
  mutate(pred_here_ib, age_diss_cen = 0, schisto_inf = 1)
)


dat_fgrow <- bind_rows(dat_fgrow, pred_fgrow_here)
```

```{r}
thin_fgrow <- 50
burnin_fgrow <- 1000
nit_fgrow <- thin_fgrow * target_post_dist_sample_size + burnin_fgrow

# inf vs uninfected effects
m0_fgrow <- MCMCglmm(
  fish_final_bm_g_noworm ~ schisto_inf*age_diss_cen + schisto_inf*fish_sex_cen + schisto_inf*fish_initial_bm_cen, 
  random = ~ tank_id,
  family = "gaussian",
  data = dat_fgrow,
  prior = p1_g,
  verbose=FALSE,
  nitt = nit_fgrow, 
  thin = thin_fgrow,
  burnin = burnin_fgrow
  )

```

Fish grew more when they were dissected later, females, and larger to begin with. The effects were not clearly dependent on infection.

```{r}
summary(m0_fgrow)
```


```{r}
# predictions from uninf vs inf models 
pred_fgrow0 <- (predict.MCMCglmm(m0_fgrow, interval = "confidence"))
pred_fgrow0 <- bind_cols(pred_fgrow_here%>%filter(pred != "yes5"),
                         data.frame(pred_fgrow0[which(dat_fgrow$pred %in% c("yesi", "yes3", "yes4", "yes6", "yesib")),]))
```

Here is the predicted difference in final mass (g) between an uninfected and infected fish (holding, size, sex, and age constant).

```{r}
pred_fgrow0%>%
  filter(pred == "yesi")%>%
  mutate(infected = if_else(schisto_inf == 0, "uninfected", "infected"))%>%
  select(infected, fit, lwr, upr)
```

Here is the effect size expressed as mg difference in final size. Interestingly, the reduction in fish mass accumulation is similar to the size of small plerocercoids.

```{r}
summary(m0_fgrow$Sol[,"schisto_inf"]*-1000)
```

Here is the predicted relationship between initial and final fish size. Infected fish grow to smaller final sizes, regardless of starting size (i.e. the lines are parallel).

```{r}
ggplot(dat_fgrow,
       aes(x = fish_initial_bm_g, y = fish_final_bm_g_noworm,
           shape = factor(schisto_inf),
           fill = factor(schisto_inf),
           color = factor(schisto_inf))) +
  geom_point(size = 0.25) + 
  geom_ribbon(data = pred_fgrow0%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2, color = NA) +
  geom_line(data = pred_fgrow0%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit,
                  linetype = factor(schisto_inf)
                  )
            ) +
  labs(x = "Fish mass at exposure (g)", y = "Fish mass at dissection (g)") +
  scale_shape_manual(values = c(15,16), labels = c("uninfected", "infected")) +
  scale_linetype_manual(values = c("dashed", "solid"), labels = c("uninfected", "infected")) +
  scale_color_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  scale_fill_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  theme(legend.title = element_blank())
```

Instead of final size, we can plot the same data as growth in mg, which might be more intuitive. Here is growth as a function of initial fish size. 

```{r}
sf_fs_e <- ggplot(dat_fgrow,
       aes(x = fish_initial_bm_g,
           y = (fish_final_bm_g_noworm - fish_initial_bm_g) * 1000,
           shape = factor(schisto_inf),
           fill = factor(schisto_inf),
           color = factor(schisto_inf))) +
  geom_point(size = 0.25) + 
  geom_ribbon(data = pred_fgrow0%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000,
                  ymin = (lwr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000, 
                  ymax = (upr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000,
                  fill = factor(schisto_inf)), 
              alpha = 0.2, color = NA) +
  geom_line(data = pred_fgrow0%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000,
                  linetype = factor(schisto_inf)
                  )
            ) +
  labs(x = "Fish mass at exposure (g)", y = "Fish growth (mg)") +
  scale_shape_manual(values = c(15,16), labels = c("uninfected", "infected")) +
  scale_linetype_manual(values = c("dashed", "solid"), labels = c("uninfected", "infected")) +
  scale_color_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  scale_fill_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  theme(legend.title = element_blank())
sf_fs_e
```

The relationship between final size and age at dissection was a little more complex. Older uninfected fish were larger than older, infected fish.

```{r}
sf_age_c <- ggplot(dat_fgrow,
       aes(x = age_dissection, 
           y = (fish_final_bm_g_noworm - fish_initial_bm_g) * 1000,
           color = factor(schisto_inf),
           shape = factor(schisto_inf))) +
  geom_point(size = 0.25) + 
  geom_ribbon(data = pred_fgrow0%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000,
                  ymin = (lwr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000, 
                  ymax = (upr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000,
                  fill = factor(schisto_inf)), 
              alpha = 0.2, color = NA) +
  geom_line(data = pred_fgrow0%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000,
                  linetype = factor(schisto_inf)
                  )
            ) +
  labs(x = "Days post exposure", y = "Fish growth (mg)") +
  scale_shape_manual(values = c(15,16), labels = c("uninfected", "infected")) +
  scale_linetype_manual(values = c("dashed", "solid"), labels = c("uninfected", "infected")) +
  scale_color_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  scale_fill_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  guides(linetype = "none", fill = "none") +
  theme(legend.title = element_blank(),
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025,0.975),
        legend.justification = c(0,1))
sf_age_c
```

Female fish tended to grow slightly larger than male fish.

```{r}
ggplot(dat_fgrow%>%
         filter(fish_sex_cen != 0), 
       aes(x = factor(fish_sex_cen), y = fish_final_bm_g_noworm, color = factor(schisto_inf))) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(position = position_jitterdodge(), alpha = 0.2) +
  geom_pointrange(
    data = pred_fgrow0%>%filter(pred == "yes4"),
    aes(x = factor(fish_sex_cen),
        y = fit, ymin = lwr, ymax = upr), 
    size = 1,
    fill = "black",
    position = position_dodge(width = 0.75)) +
  # scale_y_log10() +
  scale_x_discrete(labels = c("male", "female")) +
  scale_color_discrete(labels = c("uninfected", "infected")) +
  labs(y = "Fish mass at dissection (g)") +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
```

When we remove the raw data and just plot the model means, the difference between sexes is clear, but the effect was similar in uninfected and infected fish.

```{r}
ggplot(pred_fgrow0%>%filter(pred == "yes4"), 
       aes(x = factor(fish_sex_cen), y = fit, color = factor(schisto_inf))) +
  geom_line(aes(group = factor(schisto_inf)),
            position = position_dodge(width = 0)) +
  geom_pointrange(
    aes(ymin = lwr, ymax = upr), 
    position = position_dodge(width = 0)) +
  # scale_y_log10() +
  scale_x_discrete(labels = c("male", "female")) +
  scale_color_discrete(labels = c("uninfected", "infected")) +
  labs(y = "Fish mass at dissection (g)") +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
```

Here's the same plot, but with the y-axis as growth. 

```{r}
dx_avg_fgrow_sex <- dat_fgrow%>%
  filter(is.na(pred), !is.na(fish_sex_cen), fish_sex_cen != 0)%>%
  group_by(fish_sex_cen, schisto_inf)%>%
  summarise(
    fgrow_mean = mean((fish_final_bm_g_noworm - fish_initial_bm_g) * 1000, na.rm=T),
    n = n())%>%
  ungroup()

sf_sex_e <- ggplot(pred_fgrow0%>%filter(pred == "yes4"), 
       aes(x = factor(fish_sex_cen), 
           y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000,
           color = factor(schisto_inf),
           shape = factor(schisto_inf),
           fill = factor(schisto_inf))) +
  geom_pointrange(
    aes(ymin = (lwr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000,
        ymax = (upr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000), 
    position = position_dodge(width = dw),
    fill = "white") +
  geom_point(data = dx_avg_fgrow_sex,
             aes(y = fgrow_mean),
             position = position_dodge2(width = dw)
             ) +
  geom_text(data = dx_avg_fgrow_sex,
            aes(label = n,
                y = dx_avg_fgrow_sex%>%.$fgrow_mean%>%min()),
            vjust = 1,
            position = position_dodge2(width = dw+.2),
            size = 2.5) +
  scale_x_discrete(labels = c("male", "female")) +
  scale_shape_manual(values = c(22,21), labels = c("uninfected", "infected")) +
  scale_color_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  scale_fill_manual(values = c("goldenrod2", "black"), labels = c("uninfected", "infected")) +
  labs(y = "Fish growth (mg)") +
  theme(legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
sf_sex_e
```

As else equal, female fish grew this many more mg than male fish:

```{r}
summary(m0_fgrow$Sol[,"fish_sex_cen"]*1000)
```

Now let's focus on just the infected fish. Does final mass differ among our selection lines?

```{r}
dat_fgrow2 <- dat_fgrow%>%filter(schisto_inf == 1)
```

```{r}
# just fixed effects
m1_fgrow <- MCMCglmm(
  fish_final_bm_g_noworm ~ ib + age_diss_cen + fish_sex_cen + fish_initial_bm_cen, 
  random = ~ tank_id,
  family = "gaussian",
  data = dat_fgrow2,
  prior = p1_g,
  verbose=FALSE,
  nitt = nit_fgrow, 
  thin = thin_fgrow,
  burnin = burnin_fgrow
  )

# selection line effects
m2_fgrow <- MCMCglmm(
  fish_final_bm_g_noworm ~ ib + age_diss_cen + fish_sex_cen + fish_initial_bm_cen + gen_line, 
  random = ~ tank_id,
  family = "gaussian",
  data = dat_fgrow2,
  prior = p1_g,
  verbose=FALSE,
  nitt = nit_fgrow, 
  thin = thin_fgrow,
  burnin = burnin_fgrow
  )

```

The effects of fish size, sex, and age were similar in the infected-only model, so we do not reproduce the plots again. Like for liver mass, fish with inbred worms were somewhat larger than those with outbred worms.

```{r}
summary(m1_fgrow)
```

```{r}
# predictions from log models 
pred_fgrowib <- (predict.MCMCglmm(m1_fgrow, interval = "confidence"))
pred_fgrowib <- bind_cols(pred_fgrow_here%>%filter(pred == "yesib"),
                         data.frame(pred_fgrowib[which(dat_fgrow2$pred == "yesib"),]))
```

Fish infected with inbred worms grew more than those with oubred worms. The dashed line is mean growth in uninfected fish.

```{r}
ggplot(dat_fgrow2, 
       aes(x = ib, 
           y = (fish_final_bm_g_noworm - fish_initial_bm_g)*1000)
       ) +
  geom_hline(
    yintercept = posterior.mode( (m0_fgrow$Sol[,"(Intercept)"] - mean(dat$fish_initial_bm_g, na.rm=T)) * 1000), 
    # avg growth in uninfected
    linetype = "dashed") +
  geom_ribbon(data = pred_fgrowib%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000,
                  ymin = (lwr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000,
                  ymax = (upr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000), 
              alpha = 0.2) +
  geom_line(data = pred_fgrowib%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000,
                  )
            ) +
  geom_point(alpha = 0.2) +
  labs(y = "Stickleback growth (mg)", x = "Inbreeding coefficient") 
```

Here is the percent increase in final fish size associated with full-sib mating:

```{r}
post_fgrow_noib <- (m1_fgrow$Sol[,"(Intercept)"])
post_fgrow_ib <- (m1_fgrow$Sol[,"(Intercept)"] + m1_fgrow$Sol[,'ib']*.25)
sx <- summary(100*(post_fgrow_ib - post_fgrow_noib)/post_fgrow_noib)
sx
```
```{r}
sx <- round(sx$quantiles,1)
s_ann <- paste0("PI: ", sx[3], "% [", sx[1], " - ", sx[5], "]")
```

Here is the trend without the points.

```{r}
sf_ib_j <- ggplot(dat_fgrow2, 
       aes(x = ib, 
           y = (fish_final_bm_g_noworm - fish_initial_bm_g)*1000)
       ) +
  geom_ribbon(data = pred_fgrowib%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000,
                  ymin = (lwr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000,
                  ymax = (upr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000), 
              alpha = 0.2) +
  geom_line(data = pred_fgrowib%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000,
                  )
            ) +
  labs(y = "Fish growth (mg)", x = "Inbreeding coefficient") +
  annotate("text", label = s_ann, 
           x = pred_fgrowib%>%filter(pred == "yesib")%>%.$ib%>%max(),
           y = (pred_fgrowib%>%filter(pred == "yesib")%>%.$lwr%>%min() -
             mean(dat$fish_initial_bm_g, na.rm=T)) * 1000,
           hjust = 1)
sf_ib_j
```

Adding the selection line to the infected-only model does not seem to reduce the deviance much; actually, it might be a worse model.

```{r}
plot(mcmc.list(m1_fgrow$Deviance, m2_fgrow$Deviance), density = F)
```

Some of the line variables were significant, though.

```{r}
summary(m2_fgrow)
```


```{r}
# predictions from infected-only models 
pred_fgrow2 <- (predict.MCMCglmm(m2_fgrow, interval = "confidence"))
pred_fgrow2 <- bind_cols(pred_fgrow_here%>%filter(pred == "yes5"),
                         data.frame(pred_fgrow2[which(dat_fgrow2$pred == "yes5"),]))
```

There are not clear differences in final fish size between lines, although raw means vary due to differences in fish size, age, etc. However, the fish in the final generation grew a bit bigger than expected, matching trends in liver and plerocercoid size. Fish seem to have simply been in better condition in that generation.

```{r}
dx_avg <- dat_fgrow2%>%
  filter(is.na(pred))%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            fgrow_mean = mean(fish_final_bm_g_noworm, na.rm=T),
            fgrow_mean_g = mean(fish_final_bm_g_noworm - fish_initial_bm_g, na.rm=T)
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
ggplot(pred_fgrow2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit, color = line)) +
  annotate("rect", xmin = -0.5, xmax = 4.5,
           ymin = pred_fgrow0%>%filter(pred == "yesi", schisto_inf == 0)%>%.$lwr,
           ymax = pred_fgrow0%>%filter(pred == "yesi", schisto_inf == 0)%>%.$upr,
           alpha = 0.2) +
  geom_hline(yintercept = posterior.mode(m0_fgrow$Sol[,"(Intercept)"]), # avg growth in uninfected
             linetype = "dashed") +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = fgrow_mean),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(dx_avg$fgrow_mean)),
            position = position_dodge2(width = dw), 
            vjust = 1,
            size = 3) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Final mass at dissection (g)",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
```

We can also convert the plot to growth (final - initial size). The dashed line shows the average for uninfected fish. The raw means are not so off now, because growth mostly removes the effect of initial size.

```{r}
f4i <- ggplot(pred_fgrow2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen,
           y = (fit - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000, 
           color = line)) +
  annotate("rect", xmin = -0.5, xmax = 4.5,
           ymin = (pred_fgrow0%>%filter(pred == "yesi", schisto_inf == 0)%>%.$lwr - 
             mean(dat$fish_initial_bm_g, na.rm=T)) * 1000,
           ymax = (pred_fgrow0%>%filter(pred == "yesi", schisto_inf == 0)%>%.$upr - 
             mean(dat$fish_initial_bm_g, na.rm=T)) * 1000,
           alpha = 0.2) +
  geom_hline(yintercept = posterior.mode( (m0_fgrow$Sol[,"(Intercept)"] - mean(dat$fish_initial_bm_g, na.rm=T)) * 1000), # avg growth in uninfected
             linetype = "dashed") +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(
    aes(
      ymin = (lwr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000, 
      ymax = (upr - (fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T)))*1000
      ),
    position = position_dodge2(width = dw),
    shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = fgrow_mean_g * 1000),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, 
                y = min(pred_fgrow2$lwr - (pred_fgrow2$fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T))) * 1000
                ),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Stickleback growth (mg)",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,4.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4i
```

## Breeding traits

After dissecting fish, a subset of worms were used for breeding the next generation.

### Egg production

Here is a table of how many worms were bred. They were bred in pairs, so there were half as many clutches (i.e. full-sib families). In the last generation of the experiment, worms were not bred.

```{r}
tx <- with(dat%>%filter(!is.na(used_breeding))%>%
       mutate(used_breeding = if_else(used_breeding == 0, "no", 
                                      if_else(used_breeding == 1, "yes", "bred for other exp"))),
     table(gen, used_breeding))
tx
```
```{r}
print( paste0('avg worms per gen: ', as.character(sum(tx[,3])/4)))
rm(tx)
```

```{r}
dat_bred <- dat%>%
  filter(used_breeding != 2, !is.na(eggnum_d2_6_indiv))
```

Worms were bred in pairs for two days to allow sperm exchange before being separated to collect eggs with defined mothers and fathers (see [here](https://onlinelibrary.wiley.com/doi/full/10.1111/jeb.12165)). Therefore, portions of the eggs produced by a worm could (day 2-6) and could not (day 0-2) be assigned to individuals. We'll focus on the portion that can be assigned to individuals.

Clutch mass is determined by egg size and egg number. However, egg size did not vary much across clutches, so clutch mass was entirely determined by egg number.

```{r}
cowplot::plot_grid(
  ggplot(dat_bred, aes(eggnum_d2_6_indiv, clutchmass_d2_6_indiv)) +
    geom_point() +
    labs(x = "Eggs, day 2-6", y = "Clutch mass, day 2-6"),
  ggplot(dat_bred, aes(eggsize_d2_6_indiv, clutchmass_d2_6_indiv)) +
    geom_point() +
    labs(x = "Egg size, day 2-6", y = "Clutch mass, day 2-6")
)
```

It is also not clear that egg size variation indicates quality. Egg size is not correlated with hatching rate (panels are generation).

```{r}
ggplot(dat_bred%>%filter(!is.na(eggsize_d2_6_indiv)),
       aes(eggsize_d2_6_indiv, hatching_rate_d2_6)) +
  geom_point() + geom_smooth() +
  facet_wrap(~factor(gen)) +
  labs(x = "Egg size, day 2-6", y = "Hatching")
```

Nor is it correlated with average copepod infection rates (these rates don't account for copepod stage or block, though).

```{r}
es_avg <- dat_bred%>%
  filter(!is.na(eggs_maternal_id))%>%
  select(eggs_maternal_id, eggsize_d2_6_indiv, hatching_rate_d2_6)
ci_avg <- dat_cinf%>%
  filter(is.na(pred))%>%
  group_by(gen, worm_maternal_id)%>%
  summarise(cinf_prop = sum(cop_inf)/sum(!is.na(cop_inf)),
            n = n())

es_vs_ci <- left_join(es_avg, ci_avg, by = c("eggs_maternal_id" = "worm_maternal_id"))

ggplot(es_vs_ci%>%filter(!is.na(n)),
       aes(eggsize_d2_6_indiv, cinf_prop)) +
  geom_point(aes(size = n), alpha = 0.2) +
  geom_smooth() +
  facet_wrap(~factor(gen)) +
  labs(x = "Egg size, day 2-6", y = "Copepod infection rate")
rm(es_avg, ci_avg)
```

Making larger eggs is also not associated with producing fewer eggs, i.e. there is not a quantity-quality tradeoff.

```{r}
ggplot(dat_bred%>%filter(!is.na(eggsize_d2_6_indiv)),
       aes(eggsize_d2_6_indiv, eggnum_d2_6_indiv/worm_bm_mg)) +
  geom_point() + geom_smooth() +
  facet_wrap(~factor(gen)) +
  labs(x = "Egg size, day 2-6", y = "Eggs per mg")
```

Thus, we do not consider egg size further. Rather, we focus on fecundity (egg number), which is essentially equivalent to clutch mass.

Larger worms produce more eggs. Fecundity variance also increases with worm size, suggesting we may need to log transform fecundity.

```{r}
ggplot(dat_bred%>%
         filter(!is.na(eggs_maternal_id)),
       aes(y = eggnum_d2_6_indiv, x = worm_bm_mg)) +
  geom_point() + geom_smooth() +
  # scale_x_log10() +
  # scale_y_log10() +
  labs(y = "Eggs, day 2-6", x = "Plerocercoid mass (mg)")
```

Here's the log-log plot. The relationship is linear and the residual variance is more homogeneous, but there are some worms that produce far fewer eggs than expected.

```{r}
ggplot(dat_bred%>%
         filter(!is.na(eggs_maternal_id), eggs_clutch_id != "2_S3"),
       aes(y = eggnum_d2_6_indiv, x = worm_bm_mg)) +
  geom_point() + geom_smooth() +
  scale_x_log10() +
  scale_y_log10() +
  labs(y = "Eggs, day 2-6", x = "Plerocercoid mass (mg)")

# ggplot(dat_bred%>%
#          filter(!is.na(eggs_maternal_id), eggs_clutch_id != "2_S3"),
#        aes(y = eggnum_d2_6_indiv, x = worm_bm_mg, color = prop_total_eggnum_from_worm_d2_6)) +
#   geom_point() + geom_smooth() +
#   scale_color_distiller(palette = "Spectral") +
#   scale_x_log10() +
#   scale_y_log10() +
#   labs(y = "Eggs, day 2-6", x = "Plerocercoid mass (mg)")
```

Let's plot eggs per mg as a function of worm mass. The relationship is still positive, suggesting that larger worms produce proportionally more eggs, relative to body size.

```{r}
ggplot(dat_bred%>%
         filter(!is.na(eggs_maternal_id), eggs_clutch_id != "2_S3"),
       aes(y = eggnum_d2_6_indiv/worm_bm_mg, x = worm_bm_mg)) +
  geom_point() + geom_smooth(method =lm) +
  # scale_x_log10() +
  # scale_y_log10() +
  labs(y = "Eggs per mg", x = "Plerocercoid mass (mg)")
```

So, plerocercoid size determines fecundity, but plerocercoid size is determined by fish characteristics like size, sex, etc. Thus, we can take two approaches to modelling. First, we could use fish size, sex, and age as fixed effects. This tests which parasites produce lots of eggs, given the traits of their fish hosts. Second, we could just use parasite mass as a fixed effect, testing which worms produce more/fewer eggs relative to body size. We'll use both approaches to compare the selection lines.

We also should reconsider using tank as the random effect. While it is possible that parasites from different fish tanks differ in fecundity, there may not be enough information to test this. Most tanks yielded just 1 or 2 worms that were bred. 

```{r}
dat_bred%>%
  group_by(tank_id)%>%
  summarize(n = n())%>%
  ggplot(., aes(n)) + geom_histogram() + labs(x = "Bred worms per tank")
```

Thus, including a tank effect for fecundity gets quite close to having an observation-level predictor. The worms were bred in two rounds per generation. Therefore, instead of a tank effect, we'll include a 'breeding' block effect.

First, we'll fit the models that just use fish characteristics to predict fecundity.

```{r}
dat_bred <- dat%>%
  filter(used_breeding != 2, !is.na(eggnum_d2_6_indiv))%>%
  mutate(log_fish_initial_bm = log(fish_initial_bm_g),
         log_ww = log(worm_bm_mg))%>%
  mutate(fish_sex_cen = if_else(is.na(fish_sex_cen), 0, fish_sex_cen),
         age_diss_cen = age_dissection - med_age_diss,
         log_fish_initial_bm_cen = log_fish_initial_bm - log(mean(dat$fish_initial_bm_g, na.rm = T)),
         log_ww_cen = log_ww - log(mean(dat_bred$worm_bm_mg, na.rm = T)))

pred_bred_here <- bind_rows(
  mutate(pred_here3_i, log_ww_cen = seq(
           min(dat_bred$log_ww_cen, na.rm=T),
           max(dat_bred$log_ww_cen, na.rm=T),
           length.out = 50)),
  mutate(pred_here4_i, log_ww_cen = 0),
  mutate(pred_here3, fish_initial_bm_cen = 0, log_fish_initial_bm_cen = 0,
         pred = "yes6", schisto_inf = 1, log_ww_cen = 0,
         age_diss_cen = seq(
           min(dat_bred$age_diss_cen, na.rm=T),
           max(dat_bred$age_diss_cen, na.rm=T),
           length.out = 50)
         ),
  mutate(pred_here5, age_diss_cen = 0, log_fish_initial_bm_cen = 0, log_ww_cen = 0, schisto_inf = 1)%>%
    filter(gen != 4)%>%select(-fish_exp_on_cop_dpe)%>%distinct(),
  mutate(pred_here_ib, age_diss_cen = 0, log_ww_cen = 0)
)

pred_bred_here <- mutate(pred_bred_here, breeding_block = unique(dat_bred$breeding_block)[1])
dat_bred <- bind_rows(
  dat_bred, pred_bred_here
)
```

```{r}
thin_bred <- 200
burnin_bred <- 1000
nit_bred <- thin_bred * target_post_dist_sample_size + burnin_bred

# fixed effects
m1_bred_log <- MCMCglmm(log(eggnum_d2_6_indiv) ~ ib + log_fish_initial_bm_cen + fish_sex_cen + age_diss_cen, 
                 random = ~ breeding_block,
                 family = "gaussian",
                 data = dat_bred,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_bred, 
                 thin = thin_bred,
                 burnin = burnin_bred
                )
# fixed effects
m2_bred_log <- MCMCglmm(log(eggnum_d2_6_indiv) ~ ib + log_fish_initial_bm_cen + fish_sex_cen + age_diss_cen + gen_line, 
                 random = ~ breeding_block,
                 family = "gaussian",
                 data = dat_bred,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_bred, 
                 thin = thin_bred,
                 burnin = burnin_bred
                )
```

Worms from larger fish, and perhap female fish, produce more eggs. There is not an effect of day pi, which is not surprising; all worms for breeding were dissected from fish around the same dpi. There was a non-significant decrease in fecundity with inbreeding. There was no variance between breeding blocks in fecundity.

```{r}
summary(m1_bred_log)
# plot(m1_bred_log$VCV)
```

This is the number of eggs produced by a worm from an average fish host:

```{r}
summary(exp(m1_bred_log$Sol[,'(Intercept)']))
```

A 10% increase in initial fish mass results in this percent increase in fecundity (of course there is some fish survivor bias here);

```{r}
summary(exp(m1_bred_log$Sol[,'log_fish_initial_bm_cen'] * log(1.1)) - 1)
# summary(exp(m1_bred_log$Sol[,'log_fish_initial_bm_cen'] * log(2)) - 1) # same calc for doubling of host mass
```

Here is the percent difference in fecundity between worms from female and male fish.

```{r}
summary(exp(m1_bred_log$Sol[,'fish_sex_cen'])-1)
```

Here is the percent decrease in fecundity with half-sib breeding (F = 0.25).

```{r}
summary(1-exp(m1_bred_log$Sol[,'ib']*0.25))
```

Let's plot these effects.

```{r}
# predictions from log models 
pred_bred1_log <- exp(predict.MCMCglmm(m1_bred_log, interval = "confidence"))
pred_bred1_log <- bind_cols(pred_bred_here%>%filter(pred != "yes5"),
                           data.frame(pred_bred1_log[which(dat_bred$pred %in% c("yes3", "yes4", "yes6", "yesib")),]))
```

Here is the relationship between initial fish size and fecundity. Note the axes are not log-transformed.

```{r}
sf_fs_f <- ggplot(dat_bred, 
       aes(x = fish_initial_bm_g, y = eggnum_d2_6_indiv/1000)) +
  geom_point(size = 0.25) +
  geom_ribbon(data = pred_bred1_log%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit/1000, ymin = lwr/1000, ymax = upr/1000), 
              alpha = 0.2) +
  geom_line(data = pred_bred1_log%>%filter(pred == "yes3"),
              aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm=T),
                  y = fit/1000)
            ) +
  # scale_y_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000)) +
  labs(y = "Eggs (thousands)", x = "Fish mass at exposure (g)")
sf_fs_f
```

```{r}
sf_fs <- cowplot::plot_grid(
  sf_fs_a + guides(size = "none") + 
    theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_fs_b + guides(size = "none") + 
    theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  sf_fs_c + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_fs_d + guides(shape = "none", linetype = "none", color = "none", fill = "none") + theme(), 
  sf_fs_e + guides(shape = "none", linetype = "none", color = "none", fill = "none") + theme(), 
  sf_fs_f + theme(),
  align = "v",
  ncol = 3,
  labels = c("A", "B", "C", "D", "E", "F"))

# ggsave(sf_fs, filename = "../figs/figS_fs.png", width = 80*3, height = 60*2, units = "mm")
ggsave(sf_fs, filename = "../figs/figS_fs.svg", width = 80*3, height = 60*2, units = "mm")
# move rows down, move some y-axis labels
```

Here is the change in fecundity with time post infection.

```{r}
sf_age_d <- ggplot(dat_bred, 
       aes(x = age_dissection, y = eggnum_d2_6_indiv/1000)) +
  geom_point(size = 0.25) +
  geom_ribbon(data = pred_bred1_log%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = fit/1000, ymin = lwr/1000, ymax = upr/1000), 
              alpha = 0.2) +
  geom_line(data = pred_bred1_log%>%filter(pred == "yes6"),
              aes(x = age_diss_cen + med_age_diss,
                  y = fit/1000)
            ) +
  labs(y = "Eggs (thousands)", x = "Days post exposure") 
sf_age_d
```
```{r}
sf_age <- cowplot::plot_grid(
  sf_age_a + theme(), 
  sf_age_b + guides(shape = "none", linetype = "none", color = "none", fill = "none") + 
    theme(),
  sf_age_c + guides(color = guide_legend(override.aes = list(size = 1.5))), 
  sf_age_d + guides(shape = "none", linetype = "none", color = "none", fill = "none") + theme(),
  align = "hv",
  ncol = 2,
  labels = c("A", "B", "C", "D", "E", "F"))

# ggsave(sf_age, filename = "../figs/figS_age.png", width = 70*2, height = 60*2, units = "mm")
ggsave(sf_age, filename = "../figs/figS_age.svg", width = 70*2, height = 60*2, units = "mm")
# move rows down, move some y-axis labels
```

There's hardly an effect of sex when we control for fish size.

```{r}
ggplot(dat_bred%>%
         filter(fish_sex_cen != 0), 
       aes(x = factor(fish_sex_cen), y = eggnum_d2_6_indiv)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(alpha = 0.2) +
  geom_pointrange(
    data = pred_bred1_log%>%filter(pred == "yes4"),
    aes(x = factor(fish_sex_cen),
        y = fit, ymin = lwr, ymax = upr), 
    size = 2) +
  scale_x_discrete(labels = c("male", "female")) +
  scale_y_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000)) +
  labs(y = "Eggs") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
```

When we zoom in on the model predictions, though, we see that worms from female fish tended to produce more eggs, though the difference is not significant.

```{r}
dx_avg <- dat_bred%>%
  filter(is.na(pred), fish_sex_cen != 0, !is.na(fish_sex_cen), gen != 4)%>%
  group_by(fish_sex_cen)%>%
  summarise(n = n(),
            bred_mean = mean(eggnum_d2_6_indiv/1000, na.rm=T),
            )%>%
  ungroup()

sf_sex_f <- ggplot(pred_bred1_log%>%filter(pred == "yes4"), 
       aes(x = factor(fish_sex_cen), y = fit/1000)) +
  geom_pointrange(
    aes(ymin = lwr/1000,
        ymax = upr/1000), 
    shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = bred_mean),
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n,
                y = pred_bred1_log%>%filter(pred == "yes4")%>%.$lwr%>%min()/1000),
            vjust = 1,
            size = 2.5) +
  scale_x_discrete(labels = c("male", "female")) +
  labs(y = "Eggs (thousands)") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
sf_sex_f
```

```{r}
sf_sex <- cowplot::plot_grid(
  sf_sex_a + guides(size = "none") + 
    theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_sex_b + guides(shape = "none", linetype = "none", color = "none", fill = "none") + 
    theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  sf_sex_c + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_sex_d +  theme(), 
  sf_sex_e + guides(shape = "none", linetype = "none", color = "none", fill = "none") + theme(), 
  sf_sex_f + theme(),
  align = "v",
  ncol = 3,
  labels = c("A", "B", "C", "D", "E", "F"))

# ggsave(sf_sex, filename = "../figs/figS_fishsex.png", width = 70*3, height = 60*2, units = "mm")
ggsave(sf_sex, filename = "../figs/figS_fishsex.svg", width = 70*3, height = 60*2, units = "mm")
# move rows down, move some y-axis labels
```

Presumably, this is because worms were slightly bigger from female fish. Here is the difference in egg production of worms from male and female fish: 

```{r}
summary(
  exp(m1_bred_log$Sol[,"(Intercept)"] + m1_bred_log$Sol[,"fish_sex_cen"]*0.5) -
    exp(m1_bred_log$Sol[,"(Intercept)"] + m1_bred_log$Sol[,"fish_sex_cen"]*-0.5)
  )
```

Here is the effect of inbreeding.

```{r}
ggplot(dat_bred, 
       aes(x = ib, y = eggnum_d2_6_indiv)) +
  geom_ribbon(data = pred_bred1_log%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_bred1_log%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit)
            ) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000)) +
  labs(y = "Eggs 2-6 dpi", x = "Inbreeding coefficient") 
```

Here is how many eggs an outcrossed worm is expected to produce: 

```{r}
post_bred_noib <- exp(m1_bred_log$Sol[,"(Intercept)"])
median(post_bred_noib)
```

And how many a worm for full-mating is expected to produce:

```{r}
post_bred_ib <- exp(m1_bred_log$Sol[,"(Intercept)"] + m1_bred_log$Sol[,'ib']*.25)
median(post_bred_ib)
```

This is the percent decrease. 

```{r}
sx <- summary(100*(post_bred_noib - post_bred_ib)/post_bred_noib)
sx
```

```{r}
sx <- round(sx$quantiles,1)
s_ann <- paste0("PD: ", sx[3], "% [", sx[1], " - ", sx[5], "]")
```

Here is the inbreeding trend without the data points.

```{r}
sf_ib_k <- ggplot(dat_bred, 
       aes(x = ib, y = eggnum_d2_6_indiv/1000)) +
  geom_ribbon(data = pred_bred1_log%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit/1000, ymin = lwr/1000, ymax = upr/1000), 
              alpha = 0.2) +
  geom_line(data = pred_bred1_log%>%filter(pred == "yesib"),
              aes(x = ib,
                  y = fit/1000)
            ) +
  labs(y = "Eggs (thousands)", x = "Inbreeding coefficient") +
  annotate("text", label = s_ann, 
           x = 0,
           y = pred_bred1_log%>%filter(pred == "yesib")%>%.$lwr%>%min()/1000,
           hjust = 0)
sf_ib_k
```

Once we control for host effects, do the selection lines differ in fecundity? Here are the model parameters; just a few line parameters were significant. 

```{r}
summary(m2_bred_log)
```

However, model deviance was clearly lower in the model with selection lines. 

```{r}
plot(mcmc.list(m1_bred_log$Deviance, m2_bred_log$Deviance), density = F)
```

Let's plot the predicted fecundity in the lines for an average fish.

```{r}
# predictions from log models 
pred_bred2_log <- exp(predict.MCMCglmm(m2_bred_log, interval = "confidence"))
pred_bred2_log <- bind_cols(pred_bred_here%>%filter(pred == "yes5"),
                        data.frame(pred_bred2_log[which(dat_bred$pred == "yes5"),]))
```

After adjusting for host traits, there is little variation in fecundity from one generation to the next. However, it looks like fecundity in the selected lines was lower than in the control line. This suggests there is a cost of developing faster or slower in copepods, i.e. of being an extreme phenotype. 

```{r}
dx_avg <- dat_bred%>%
  filter(is.na(pred), gen != 4)%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            bred_mean = mean(eggnum_d2_6_indiv, na.rm=T),
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4j <- ggplot(pred_bred2_log%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit/1000, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr/1000, ymax = upr/1000),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = bred_mean/1000),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(pred_bred2_log$lwr)/1000),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Eggs (thousands)",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,3.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4j
```

To formally test this, we'll pool the fast and slow breeders and leave out 'generation'  (it is not significant as a main effect).

```{r}
dat_bred2 <- dat_bred%>%
  filter(is.na(pred) | pred == "yes5")%>%
  mutate(gen_fct = as.character(gen), 
         line_pool = if_else(line %in% c("fast", "slow"), "selected", line))%>%
  mutate(gen_line_pool = paste(gen_fct, line_pool, sep = "_"))
```

```{r}
# fixed effects
m2_bred_log2 <- MCMCglmm(log(eggnum_d2_6_indiv) ~ log_fish_initial_bm_cen + fish_sex_cen + age_diss_cen +
                           line_pool,
                 random = ~ breeding_block,
                 family = "gaussian",
                 data = dat_bred2,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_bred, 
                 thin = thin_bred,
                 burnin = burnin_bred
                )
```

This is an improvement (green) compared to the model with just host traits (black) or with host traits and generation x line (red).

```{r}
plot(mcmc.list(m1_bred_log$Deviance, m2_bred_log$Deviance, m2_bred_log2$Deviance), density = F)
```

We can plot the difference between control and selected lines.

```{r}
pred_bred2_log2 <- exp(predict.MCMCglmm(m2_bred_log2, interval = "confidence"))
pred_bred2_log2 <- bind_cols(pred_bred_here%>%filter(pred == "yes5"),
                             data.frame(pred_bred2_log2[which(dat_bred2$pred == "yes5"),]))
pred_bred2_log2 <- pred_bred2_log2%>%
  mutate(line_pool = if_else(line %in% c("fast", "slow"), "selected", line))%>%
  select(line_pool, pred, fit, upr, lwr)%>%
  distinct()
```

```{r}
ggplot(dat_bred2, 
       aes(x = line_pool, y = eggnum_d2_6_indiv)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(alpha = 0.2) +
  geom_pointrange(
    data = pred_bred2_log2%>%filter(pred == "yes5"),
    aes(x = line_pool,
        y = fit, ymin = lwr, ymax = upr), 
    size = 2) +
  scale_y_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000)) +
  labs(y = "Eggs") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
```

When we zoom in on the model predictions, we see that, all else equal, worms from the control line produced more eggs than those from the initial population and from the selected lines.

```{r}
ggplot(pred_bred2_log2%>%filter(pred == "yes5"), 
       aes(x = line_pool, y = fit)) +
  geom_pointrange(
    aes(ymin = lwr,
        ymax = upr), 
    size = 1) +
  labs(y = "Eggs") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
```

This is the percent increase in fecundity in the control line relative to the selected lines.

```{r}
summary(exp(m2_bred_log2$Sol[,'line_poolcontrol'] - m2_bred_log2$Sol[,'line_poolselected'])-1)
```

In absolute terms, this corresponds to this many more eggs from controls than selecteds:

```{r}
summary(  exp( m2_bred_log2$Sol[,'(Intercept)'] + m2_bred_log2$Sol[,'line_poolcontrol'] ) -
            exp( m2_bred_log2$Sol[,'(Intercept)'] + m2_bred_log2$Sol[,'line_poolselected'] ) )
```

Now, let's refit our models using worm body mass instead of using fish traits to predict fecundity. We first fit a model with only worm mass and then one with worm mass and line. Since fish traits predicted plerocercoid size and fecundity well, we would expect the results with worm mass to be comparable to those with fish traits.

```{r}
# fixed effects
m1_bred_log_ww <- MCMCglmm(log(eggnum_d2_6_indiv) ~ log_ww_cen, 
                 random = ~ breeding_block,
                 family = "gaussian",
                 data = dat_bred,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_bred, 
                 thin = thin_bred,
                 burnin = burnin_bred
                )
# fixed effects
m2_bred_log_ww <- MCMCglmm(log(eggnum_d2_6_indiv) ~ log_ww_cen + gen_line, 
                 random = ~ breeding_block,
                 family = "gaussian",
                 data = dat_bred,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_bred, 
                 thin = thin_bred,
                 burnin = burnin_bred
                )
```

The model with worm mass instead of fish traits is better, suggesting worm mass is a better predictor of fecundity than fish traits, which makes sense.

```{r}
plot(mcmc.list(m1_bred_log$Deviance, m1_bred_log_ww$Deviance), density = F)
```

This is the number of eggs produced by an average-sized worm:

```{r}
summary(exp(m1_bred_log_ww$Sol[,'(Intercept)']))
```

Fecundity increased disproportionally with body mass. A 10% increase in plerocercoid size results in this percent increase in fecundity:

```{r}
summary(exp(m1_bred_log_ww$Sol[,'log_ww_cen'] * log(1.1)) - 1)
# summary(exp(m1_bred_log$Sol[,'log_fish_initial_bm_cen'] * log(2)) - 1) # same calc for doubling of host mass
```

```{r}
# predictions from log models 
pred_bred1_log_ww <- exp(predict.MCMCglmm(m1_bred_log_ww, interval = "confidence"))
pred_bred1_log_ww <- bind_cols(pred_bred_here%>%filter(pred == "yes3"),
                               data.frame(pred_bred1_log_ww[which(dat_bred$pred == "yes3"),]))
```

Now we can plot the relationship between plerocercoid size and fecundity. Note the axes are not log-transformed.

```{r}
ggplot(dat_bred, 
       aes(x = worm_bm_mg, y = eggnum_d2_6_indiv)) +
  geom_ribbon(data = pred_bred1_log_ww%>%filter(pred == "yes3"),
              aes(x = exp(log_ww_cen + log(mean(dat_bred$worm_bm_mg, na.rm = T))),
                  y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2) +
  geom_line(data = pred_bred1_log_ww%>%filter(pred == "yes3"),
              aes(x = exp(log_ww_cen + log(mean(dat_bred$worm_bm_mg, na.rm = T))),
                  y = fit)
            ) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000)) +
  labs(y = "Eggs, day 2-6", x = "Plerocercoid mass (g)") 
```

Based on the previous models, we would expected parasites from the selected lines to fall below the line, i.e. they produce fewer eggs for their size. The model with the selection lines looks like an improvement compared to the one with just worm mass.

```{r}
plot(mcmc.list(m1_bred_log_ww$Deviance, m2_bred_log_ww$Deviance), density = F)
```

Here are the model parameters. 

```{r}
summary(m2_bred_log_ww)
```

```{r}
# predictions from log models 
pred_bred2_log_ww <- exp(predict.MCMCglmm(m2_bred_log_ww, interval = "confidence"))
pred_bred2_log_ww <- bind_cols(pred_bred_here%>%filter(pred == "yes5"),
                        data.frame(pred_bred2_log_ww[which(dat_bred$pred == "yes5"),]))
```

And when we plot the model predictions, we see that, holding worm size constant, the selected lines have consistently lower fecundity.

```{r}
dx_avg <- dat_bred%>%
  filter(is.na(pred), gen != 4)%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            bred_mean = mean(eggnum_d2_6_indiv, na.rm=T),
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
ggplot(pred_bred2_log_ww%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = bred_mean),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(pred_bred2_log_ww$lwr)),
            position = position_dodge2(width = dw), 
            vjust = 1,
            size = 3) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Eggs, day 2-6",
       x = "Generation") +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
```

To formally test this, we'll again pool the fast and slow breeders and leave out 'generation' which was not significant anyhow. 

```{r}
m2_bred_log2_ww <- MCMCglmm(log(eggnum_d2_6_indiv) ~ log_ww_cen + line_pool,
                 random = ~ breeding_block,
                 family = "gaussian",
                 data = dat_bred2,
                 prior = p1_g,
                 verbose=FALSE,
                 nitt = nit_bred, 
                 thin = thin_bred,
                 burnin = burnin_bred
                )
```

As before, this simpler model is an improvement.

```{r}
plot(mcmc.list(m1_bred_log_ww$Deviance, m2_bred_log_ww$Deviance, m2_bred_log2_ww$Deviance), density = F)
```

The difference in fecundity between control and selected lines is similar to before with the host traits.

```{r}
pred_bred2_log_ww <- exp(predict.MCMCglmm(m2_bred_log2, interval = "confidence"))
pred_bred2_log_ww <- bind_cols(pred_bred_here%>%filter(pred == "yes5"),
                             data.frame(pred_bred2_log_ww[which(dat_bred2$pred == "yes5"),]))
pred_bred2_log_ww <- pred_bred2_log_ww%>%
  mutate(line_pool = if_else(line %in% c("fast", "slow"), "selected", line))%>%
  select(line_pool, pred, fit, upr, lwr)%>%
  distinct()
```

```{r}
ggplot(dat_bred2, 
       aes(x = line_pool, y = eggnum_d2_6_indiv)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(alpha = 0.2) +
  geom_pointrange(
    data = pred_bred2_log_ww%>%filter(pred == "yes5"),
    aes(x = line_pool,
        y = fit, ymin = lwr, ymax = upr), 
    size = 2) +
  scale_y_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000)) +
  labs(y = "Eggs") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
```

When we zoom in on the model predictions, we see that, all else equal, worms from the control line produced more eggs than those from the initial population and from the selected lines.

```{r}
ggplot(pred_bred2_log_ww%>%filter(pred == "yes5"), 
       aes(x = line_pool, y = fit)) +
  geom_pointrange(
    aes(ymin = lwr,
        ymax = upr), 
    size = 1) +
  labs(y = "Eggs") +
  theme(panel.grid.major.x = element_blank(),
        axis.title.x = element_blank())
```

This is the percent increase in fecundity in the control line relative to the selected lines.

```{r}
summary(exp(m2_bred_log2_ww$Sol[,'line_poolcontrol'] - m2_bred_log2_ww$Sol[,'line_poolselected'])-1)
```

In absolute terms, this many more eggs were produced by average-sized controls than by selecteds:

```{r}
summary(  exp( m2_bred_log2_ww$Sol[,'(Intercept)'] + m2_bred_log2_ww$Sol[,'line_poolcontrol'] ) -
            exp( m2_bred_log2_ww$Sol[,'(Intercept)'] + m2_bred_log2_ww$Sol[,'line_poolselected'] ) )
```

### Hatching

The last trait to consider is egg hatching rate. In contrast to egg quantity, egg hatching does not clearly depend on fish traits.

```{r}
cowplot::plot_grid(
 ggplot(dat_bred%>%filter(is.na(pred)), aes(fish_initial_bm_g,hatching_rate_d2_6)) +
  geom_point() + geom_smooth() +
   labs(y = "Hatching rate", x = "Initial fish mass"),
 ggplot(dat_bred%>%filter(is.na(pred)), aes(age_dissection,hatching_rate_d2_6)) +
  geom_point() + geom_smooth() +
   labs(y = "Days post infection", x = "Initial fish mass"),
 ggplot(dat_bred%>%filter(is.na(pred)), aes(factor(fish_sex),hatching_rate_d2_6)) +
   geom_boxplot(outlier.color = NA) +
   geom_jitter() +
   labs(y = "Days post infection", x = "Fish sex"),
 nrow = 1
)
```

Hatching is also not clearly determined by parasite size, by the size of the breeding partner, by the size difference between worms, or by how many eggs were produced by the worm. So, bigger worms, which tend to invest relatively more into female function, do not clearly have impaired sperm and unfertilized eggs. Also, conflict between worms caused by size differences (the hermaphrodite's dilemma) do not result in low hatching (we tried to avoid this dilemma through size matching). Parasites also do not clearly run out of sperm when they produce proportionally more eggs.

```{r}
cowplot::plot_grid(
 ggplot(dat_bred%>%filter(is.na(pred)), aes(worm_bm_mg,hatching_rate_d2_6)) +
  geom_point() + geom_smooth() +
   labs(y = "Hatching rate", x = "Plerocercoid mass"),
 ggplot(dat_bred%>%filter(is.na(pred)), aes(breeding_partner_size_mg,hatching_rate_d2_6)) +
  geom_point() + geom_smooth() +
   labs(y = "Days post infection", x = "Plerocercoid mass of partner"),
 ggplot(dat_bred%>%filter(is.na(pred)), aes(diff_mg_to_breeding_partner+.1,hatching_rate_d2_6)) +
  geom_point() + geom_smooth() +
   scale_x_log10() +
   labs(y = "Days post infection", x = "Size difference to partner"),
 ggplot(dat_bred%>%filter(is.na(pred)), aes(prop_total_eggnum_from_worm_d2_6,hatching_rate_d2_6)) +
  geom_point() + geom_smooth() +
   labs(y = "Days post infection", x = "Prop. total eggs in clutch"),
 nrow = 2
)
```

Hatching rates could of course vary due to being measured at different times. Indeed, they were lower in some generations and breeding blocks than others.

```{r}
ggplot(dat_bred, aes(breeding_block,hatching_rate_d2_6, color = factor(gen))) +
  geom_boxplot(outlier.color = NA) +
  geom_jitter() +
  labs(color = "Generation") +
  theme(axis.text.x = element_blank(),
        panel.grid.major.x = element_blank())
```

Hatching may be less an individual trait and more a clutch trait (i.e. a characteristic of the breeding pair). To examine this, let's compare hatching rates between worms that mated with each other. There is a clear correlation, which suggests the genetic combination is an important determinant of hatching.

```{r}
hr_clutch <- left_join(
  dat_bred%>%
    select(eggs_clutch_id, eggs_maternal_id, hatching_rate_d2_6)%>%
    filter(grepl("A", x = eggs_maternal_id)),
  dat_bred%>%
    select(eggs_clutch_id, eggs_maternal_id, hatching_rate_d2_6)%>%
    filter(grepl("B", x = eggs_maternal_id)),
  by = "eggs_clutch_id"
)

ggplot(hr_clutch, aes(hatching_rate_d2_6.x, hatching_rate_d2_6.y)) +
  geom_point() + geom_smooth() +
  geom_abline(linetype = "dashed") +
  labs(x = "Hatching rate, first worm", y = "Hatching rate, second worm")
```

Since some worms produced eggs that were more inbred than others, let's look at the inbreeding coefficient of offspring as a predictor of hatching. Eggs that are inbred appear less likely to hatch.

```{r}
ib_clutch <- dat%>%
  select(worm_full_sib_fam_id, ib_offspring = ib)%>%
  distinct()

dat_hatch <- left_join(dat_bred, ib_clutch, by = c("eggs_clutch_id" = "worm_full_sib_fam_id"))
```
```{r}
ggplot(dat_hatch, aes(x = ib_offspring, hatching_rate_d2_6)) + geom_point() + geom_smooth() 
```

Let's fit a model comparable to the fecundity model. Fish size, sex, and dpe are used as fixed effects and breeding block is a random effect. We also include inbreeding coefficent of the offspring and the parent. Further, we include 'clutch' as a random effect (i.e. worms that were bred together and then separated; the offspring should be genetically identical but with different mothers and fathers). Then, we add selection lines in the second model. The model has quasibinomial errors.

```{r}
dat_hatch <- dat_hatch%>%
  mutate(eggs_clutch_id = if_else(!is.na(pred), unique(dat_bred$eggs_clutch_id)[1], eggs_clutch_id),
         ib = if_else(is.na(ib) & !is.na(pred), 0, ib),
         ib_offspring = if_else(is.na(ib_offspring), 0, ib_offspring)
         )%>%
  mutate(maternal_AB = if_else(grepl("A", x = eggs_maternal_id), "A", "B"))

dat_hatch <- bind_rows(
  dat_hatch,
  # predictions for egg IB
  filter(dat_hatch, pred == "yesib")%>%
    mutate(pred = "yesiboffspring", 
           ib_offspring = ib)%>%
    mutate(ib = 0)
)
```

```{r}
p2_g <- list(R = list(V = 1, nu = 0.002),
             G = list(G1 = list(V = 1, nu = 0.002),
                      G2 = list(V = 1, nu = 0.002)))

thin_hatch <- 50
burnin_hatch <- 1000
nit_hatch <- thin_hatch * target_post_dist_sample_size + burnin_hatch


# fixed effects
m1_hatch <- MCMCglmm( cbind(hatched, eggs_checked-hatched) ~ 
                        ib + ib_offspring + fish_initial_bm_cen + fish_sex_cen + age_diss_cen, 
                 random = ~ breeding_block + eggs_clutch_id,
                 family = "multinomial2",
                 data = dat_hatch,
                 prior = p2_g,
                 verbose=FALSE,
                 nitt = nit_hatch, 
                 thin = thin_hatch,
                 burnin = burnin_hatch
                )
# fixed effects
m2_hatch <- MCMCglmm( cbind(hatched, eggs_checked-hatched) ~ 
                        ib + ib_offspring + fish_initial_bm_cen + fish_sex_cen + age_diss_cen + gen_line, 
                 random = ~ breeding_block + eggs_clutch_id,
                 family = "multinomial2",
                 data = dat_hatch,
                 prior = p2_g,
                 verbose=FALSE,
                 nitt = nit_hatch, 
                 thin = thin_hatch,
                 burnin = burnin_hatch
                )
```

The model suggests hatching is higher for eggs from larger fish, from outbred worms, and when worms are unrelated. Also, there is a clear 'clutch' effect. 

```{r}
summary(m1_hatch)
```

There was twice as much variance between clutches (clutch RE) as within them (residual variance).  

```{r}
summary(m1_hatch$VCV[,"eggs_clutch_id"]/m1_hatch$VCV[,"units"])
```

Here is a slope plot to visualize the variance within and between clutches.

```{r}
ggplot(dat_bred%>%
         mutate(maternal_AB = if_else(grepl("A", x = eggs_maternal_id), "A", "B")),
       aes(maternal_AB, hatching_rate_d2_6)) +
  geom_line(aes(group = eggs_clutch_id), alpha = 0.5, color = 'black') +
  geom_point(alpha = 0.25) +
  # scale_color_distiller(palette = "Spectral") +
  labs(x = "Maternal clutch", y = "Hatching rate") +
  theme(panel.grid.major.x = element_blank())
```

The differences between clutches are easier to see in a dot plot. The points are color coded by fish mass. Given the model parameters, we would expect more red points to the right and blue points on the left (i.e. worms from big fish and small fish have high and low hatching rates respectively). But there is not an obvious pattern.

```{r}
clutch <- dat_hatch%>%
  filter(is.na(pred))%>%
  group_by(eggs_clutch_id)%>%
  summarise(mean_hatching = mean(hatching_rate_d2_6, na.rm=T))%>%
  arrange((mean_hatching))%>%
  .$eggs_clutch_id
ggplot(dat_hatch%>%
         mutate(eggs_clutch_id = fct_relevel(eggs_clutch_id, clutch)),
       aes(x = eggs_clutch_id, y = hatching_rate_d2_6)) +
  geom_line(aes(group = eggs_clutch_id), color = "gray") +
  geom_point(aes(color = fish_initial_bm_g)) +
  theme(axis.text.x = element_blank(), 
        panel.grid.major.x = element_blank()) +
  scale_color_distiller(palette = "Spectral") +
  labs(y = "Hatching rate", x = "Clutch", color = "Fish mass") 
```

Let's plot the predicted correlation between fish mass and hatching rate.

```{r}
# manual prediction, correcting for set variance comp
c2 <- ((16 * sqrt(3))/(15 * pi))^2

# first model
post_sol1 <- m1_hatch$Sol/sqrt(1 + c2 * m1_hatch$VCV[, 'units']) # correction suggested in course notes
pdx <- m1_hatch$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_hatch$pred %in% c("yes3", "yes4", "yes6", "yesib", "yesiboffspring")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m1_hatch$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol1[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(filter(dat_hatch, pred %in% c("yes3", "yes4", "yes6", "yesib", "yesiboffspring")),
                 hatch_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_hatch1 <- px%>%
  pivot_longer(
    cols = hatch_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, ib, ib_offspring, fish_initial_bm_cen, age_diss_cen, fish_sex_cen, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

The trend is positive but not steep. The relationship also does not fit the data particularly well.

```{r}
ggplot(pred_hatch1%>%
         filter(pred == "yes3"), 
       aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T), 
           y = fit)) +
  geom_ribbon(aes(ymin = upr, ymax = lwr), alpha = 0.25, color = NA) +
  geom_line(alpha = 1) +
  geom_point(data = dat_hatch, 
             aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T), 
                 y = hatching_rate_d2_6)) +
  labs(x = "Initial fish mass", y = "Hatching rate") +
  theme()
```

The positive relationship is clearer when we look within 'breeding blocks'. Here is the same plot, but with panels separating breeding blocks. Within blocks, the trend is often positive, though the mean hatching (the intercept) varies. 

```{r}
ggplot(pred_hatch1%>%
         filter(pred == "yes3"), 
       aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T), 
           y = fit)) +
  geom_ribbon(aes(ymin = upr, ymax = lwr), alpha = 0.25, color = NA) +
  geom_line(alpha = 1) +
  geom_point(data = dat_hatch, 
             aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T), 
                 y = hatching_rate_d2_6)) +
  geom_smooth(data = dat_hatch, 
             aes(x = fish_initial_bm_cen + mean(dat$fish_initial_bm_g, na.rm = T), 
                 y = hatching_rate_d2_6),
             method = lm, se = F) +
  labs(x = "Initial fish mass", y = "Hatching rate") +
  theme() +
  facet_wrap(~breeding_block)
```

The age vs hatching rate relationship was negative, but this was confounded with block effects; the blocks characterized by low hatching also happened to be those in which fish were dissected later. Since I do not see why age would impact hatching negatively, I suspect this relationship is spurious.

```{r}
ggplot(pred_hatch1%>%
         filter(pred == "yes6"), 
       aes(x = age_diss_cen + med_age_diss, 
           y = fit)) +
  geom_ribbon(aes(ymin = upr, ymax = lwr), alpha = 0.25, color = NA) +
  geom_line(alpha = 1) +
  geom_point(data = dat_hatch, 
             aes(x = age_diss_cen + med_age_diss, 
                 y = hatching_rate_d2_6,
                 color = breeding_block)) +
  labs(x = "Days post infection", y = "Hatching rate") +
  theme()
```

Here is the effect of the parent's inbreeding coefficient. Inbred worms produce eggs that are less likely to hatch.

```{r}
ggplot(pred_hatch1%>%
         filter(pred == "yesib"), 
       aes(x = ib, 
           y = fit)) +
  geom_ribbon(aes(ymin = upr, ymax = lwr), alpha = 0.25, color = NA) +
  geom_line(alpha = 1) +
  geom_point(data = dat_hatch, 
             aes(x = ib, 
                 y = hatching_rate_d2_6
                 ),
             alpha = 0.2) +
  labs(x = "Inbreeding coefficient of parent", y = "Hatching rate") +
  theme()
```

Moreover, if the worm was paired with a relative, such that the eggs are inbred, they are less likely to hatch.

```{r}
ggplot(pred_hatch1%>%
         filter(pred == "yesiboffspring"), 
       aes(x = ib_offspring, 
           y = fit)) +
  geom_ribbon(aes(ymin = upr, ymax = lwr), alpha = 0.25, color = NA) +
  geom_line(alpha = 1) +
  geom_point(data = dat_hatch, 
             aes(x = ib_offspring, 
                 y = hatching_rate_d2_6
                 ),
             alpha = 0.2) +
  labs(x = "Inbreeding coefficient of eggs", y = "Hatching rate") +
  theme()
```

The model suggested this trend with offspring IB was stronger. Here is the odds ratio associated with full-sib mating:

```{r}
post_hatch_noib <- boot::inv.logit(post_sol1[,"(Intercept)"])
post_hatch_ib <- boot::inv.logit(post_sol1[,"(Intercept)"] + post_sol1[,'ib']*.25)
sx <- summary(
  post_hatch_ib/
  post_hatch_noib
)
sx
```
```{r}
sx <- round(sx$quantiles,2)
s_ann <- paste0("OR: ", sx[3], " [", sx[1], " - ", sx[5], "]")
```


```{r}
sf_ib_l <- ggplot(pred_hatch1%>%
         filter(pred == "yesiboffspring"), 
       aes(x = ib_offspring, 
           y = fit)) +
  geom_ribbon(aes(ymin = upr, ymax = lwr), alpha = 0.25, color = NA) +
  geom_line(alpha = 1) +
  labs(x = "Inbreeding coefficient", y = "Hatching rate") +
  theme() +
  annotate("text", label = s_ann, 
           x = 0,
           y = pred_hatch1%>%filter(pred == "yesiboffspring")%>%.$lwr%>%min(),
           hjust = 0)
sf_ib_l
```
```{r}
sf_ib <- cowplot::plot_grid(
  sf_ib_b + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_ib_a + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  sf_ib_c + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_ib_d + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_ib_e + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_ib_f + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_ib_g + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  sf_ib_h + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  sf_ib_i + theme(plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_ib_j + theme(plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_ib_k + theme(plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_ib_l + theme(plot.margin = margin(1, 5.5, 1, 5.5)), 
  sf_ib_x + theme(plot.margin = margin(1, 5.5, 1, 5.5)), 
  align = "hv",
  ncol = 5,
  labels = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M"))

# ggsave(sf_ib, filename = "../figs/figS_ib.png", width = 80*5, height = 70*3, units = "mm")
ggsave(sf_ib, filename = "../figs/figS_ib.svg", width = 80*5, height = 70*3, units = "mm")
# move rows down, move some y-axis labels
```


Now, let's compare lines. There is maybe a slight improvement by adding line to the model.

```{r}
plot(mcmc.list(m1_hatch$Deviance, m2_hatch$Deviance), density = F)
```

Here are the model parameters. A few line terms are significant.

```{r}
summary(m2_hatch)
```

```{r}
# manual prediction, correcting for set variance comp
c2 <- ((16 * sqrt(3))/(15 * pi))^2

# first model
post_sol2 <- m2_hatch$Sol/sqrt(1 + c2 * m2_hatch$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_hatch$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_hatch$pred == "yes5") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_hatch$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(filter(dat_hatch, pred == "yes5"),
                 hatch_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_hatch2 <- px%>%
  pivot_longer(
    cols = hatch_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, gen, line, gen_line, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

However, when we plot the model predictions, we see that hatching rates do not differ consistently between groups. For example, compared to controls, the slow line had lower hatching in generation 2, whereas the fast line had lower hatching in generation 3.

```{r}
dx_avg <- dat_hatch%>%
  filter(is.na(pred), gen != 4)%>%
  group_by(gen, line, gen_line)%>%
  summarise(n = n(),
            hatch_mean = mean(hatching_rate_d2_6, na.rm=T),
            )%>%
  ungroup()%>%
  mutate(line = fct_relevel(line, c("base", "fast", "control", "slow")))

dw <- 0.6
f4k <- ggplot(pred_hatch2%>%
         mutate(line = factor(line, levels = c("base", "fast", "control", "slow"))),
       aes(x = gen, y = fit, color = line)) +
  geom_line(aes(group = line),
            position = position_dodge2(width = dw)) +
  geom_pointrange(aes(ymin = lwr, ymax = upr),
                  position = position_dodge2(width = dw),
                  shape = 1) +
  geom_point(data = dx_avg, 
             aes(y = hatch_mean),
             position = position_dodge2(width = dw), 
             shape = 16) +
  geom_text(data = dx_avg, 
            aes(label = n, y = min(pred_hatch2$lwr)),
            position = position_dodge2(width = dw+.25), 
            vjust = 1,
            size = 2) +
  scale_color_manual(values = c("gray", "red", "black", "blue")) +
  labs(y = "Egg hatching rate",
       x = "Generation") +
  coord_cartesian(xlim = c(-.1,3.25)) +
  theme(panel.grid.major.x = element_blank(),
        legend.title = element_blank())
f4k
```

```{r}
## hatching and copepd infection rate are correlated across maternal clutches
# ggplot(es_vs_ci, aes(hatching_rate_d2_6, cinf_prop)) +
#   geom_point(aes(size = n), alpha = 0.2) +
#   geom_smooth() +
#   facet_wrap(~factor(gen)) +
#   labs(x = "Hatching rate", y = "Copepod infection rate")
```

```{r}
f4 <- cowplot::plot_grid(
  f4a + guides(color = F) + theme(axis.title.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)), 
  f4b + guides(color = F) + theme(axis.title.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  f4c + guides(color = F) + theme(plot.margin = margin(1, 5.5, 1, 5.5)),
  f4e + guides(color = F) + theme(axis.title.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  f4g + guides(color = F) + theme(axis.title.x = element_blank(), plot.margin = margin(1, 5.5, 1, 5.5)),
  NULL,
  f4j + guides(color = F) + theme(plot.margin = margin(1, 5.5, 5.5, 5.5)),
  f4k + guides(color = F) + theme(plot.margin = margin(1, 5.5, 5.5, 5.5)),
  align = "hv",
  ncol = 3,
  labels = c("A", "B", "C", "D", "E", "", "F", "G"))
# ggsave(f4, filename = "../figs/fig4_correlated.png", width = 270, height = 70*3, units = "mm")
ggsave(f4, filename = "../figs/fig4_correlated.svg", width = 270, height = 70*3, units = "mm") 
# move rows closer together
```

```{r}
load("03survival_plot.RData")
```

```{r}
f5 <- cowplot::plot_grid(
  f4d + guides(color = F) + theme(),
  f4x + guides(color = F) + theme(),
  f4y + guides(color = F) + theme(),
  f4f + guides(color = F) + theme(),
  f4h + guides(color = F) + theme(),
  f4i + guides(color = F) + theme(),
  align = "hv",
  ncol = 3,
  labels = "AUTO")
# ggsave(f5, filename = "../figs/fig5_correlated.png", width = 270, height = 70*2, units = "mm")
ggsave(f5, filename = "../figs/fig5_correlated.svg", width = 270, height = 70*2, units = "mm")
```

```{r}
save.image(file = "02testing_selection_response.RData")
```

# Fitness over full life cycle

So, the parasites selected for fast development are more likely to infect fish, but produce fewer eggs. Do these effects cancel out? Let's calculate the probability that parasites from the different lines survive particular life stages and then mass fecundity by survival probability.

## Probability of surviving until infecting second host

For fitness calculations, we'll extract the mean infection rates, survival, and fecundity from the models' posterior distribution, so the estimates are standardized for things like copepod stage, fish size, etc. First, we want to extract copepod infection rates, copepod survival rates, and fish infection rates. Moreover, for survival and fish infectivity, we want to express these rates as functions of time.

```{r}
# second model
post_sol2 <- m2_cinf$Sol/sqrt(1 + c2 * m2_cinf$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_cinf$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_cinf$pred == "yes2") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_cinf$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here2,
                 cinf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_cinf2x <- px%>%
  pivot_longer(
    cols = cinf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "cop_inf"
  )

# second model
post_sol2 <- m2_surv$Sol/sqrt(1 + c2 * m2_surv$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_surv$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_surv13_2$pred == "yes2") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_surv$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here2,
                 surv_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_surv2x <- px%>%
  pivot_longer(
    cols = surv_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )
pred_surv2x <- pred_surv2x%>%mutate(mort_rate = log(1-mod_pred)/13)%>%
  select(gen, line, iter, mort_rate)


# third model
post_sol3 <- m3_finf$Sol/sqrt(1 + c2 * m3_finf$VCV[, 'units']) # correction suggested in course notes
pdx <- m3_finf$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_finf$pred %in% c("yes5")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m3_finf$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol3[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here5%>%
                   mutate(gen_line_dpe = paste(gen_line, as.character(fish_exp_on_cop_dpe), sep = "_")),
                 finf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_finf3x <- px%>%
  pivot_longer(
    cols = finf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "fish_inf"
  )
pred_finf3x <- pred_finf3x%>%
  select(gen, line, iter, fish_exp_on_cop_dpe, fish_initial_bm_cen, fish_sex_cen, fish_inf)
```

Survival probability as a function of time is simply (e^(mortality rate x time in copepods)). But fish infection rates are more complex, as they are zero prior to infectivity and then they asymptote. So, we fit a non-linear function, with three parameters: the minimum time to infectivity, the asymptotic infection rate in fish, and the rate at which the asymptote is approached. Fitting such curves to limited data is difficult (n = 3 time points per line in the final generation), so we estimated the parameters as follows. First, using the whole set of infection rates, we estimated time to infectivity (tmin) for each sample in the posterior distribution. Then, we used this as the starting value to estimate the rate at which the asymptote is approached (estimating both parameters simultaneously often did not converge, e.g. late infectivity and then huge slopes). Finally, we re-estimated the minimum value to infectivitiy separately for each line. In all models, the asymptote was set as the maximum infectivity.

```{r}
# find tmin for each iteration, using all mean fish infection rates
pred_finf3x_find_inittmin <- pred_finf3x%>%
  group_by(iter)%>%
  mutate(asy_d16 = max(fish_inf))%>%
  nest()

init_tmin_est <- function(dy){
  asy_y <- dy$asy_d16
  fi_all <- nls(fish_inf ~ asy_y * (1 - exp(-c_rate*(fish_exp_on_cop_dpe - tmin)) ),
                start = list(c_rate = 0.5, tmin = 10),
                control = nls.control(maxiter = 1000, tol = 8e-8),
                data = dy,
                trace = F)
  tmin <- coef(fi_all)["tmin"]
  return(tmin)
}


pred_finf3x_find_inittmin <- pred_finf3x_find_inittmin%>%
  mutate(init_tmin = map_dbl(data, init_tmin_est))

# add initial tmin estimate to posterior dist
pred_finf3x_find_c <- pred_finf3x%>%
  filter(gen == 4)%>%
  left_join(., pred_finf3x_find_inittmin%>%select(iter, init_tmin))%>%
  group_by(iter, line)%>%
  mutate(asy_d = max(fish_inf))%>%
  nest()
```

```{r}
# use initial tmin to estimate c, the rate of approach to asymptote
c_rate_est <- function(dy){
  fi_c <- nls(fish_inf ~ asy_d * (1 - exp(-c_rate*(fish_exp_on_cop_dpe - init_tmin)) ),
          start = list(c_rate = 0.5),
          control = nls.control(maxiter = 1000),
          data = dy,
          trace = F)
  c_rate <- coef(fi_c)["c_rate"]
  return(c_rate)
}

pred_finf3x_find_c <- pred_finf3x_find_c%>%
  mutate(c_rate = map_dbl(data, c_rate_est))

# unnest and renest data, so that c_rate is in 'data' list col
pred_finf3x_find_c <- pred_finf3x_find_c%>%
  unnest()%>%
  nest()

# use c_rate to reestimate the minimum separately for different selection lines
tmin_est <- function(dy){
  fi_c <- nls(fish_inf ~ asy_d * (1 - exp(-c_rate*(fish_exp_on_cop_dpe - tmin2)) ),
          start = list(tmin2 = dy$init_tmin[1]),
          control = nls.control(maxiter = 1000),
          data = dy,
          trace = F)
  tmin2 <- coef(fi_c)["tmin2"]
  return(tmin2)
}

pred_finf3x_find_c <- pred_finf3x_find_c%>%
  mutate(tmin2 = map_dbl(data, tmin_est))
```

```{r}
# unnest data frame - now for each posterior draw, we have estimated time to infectivity, asymptote, and slope to asymptote for each selection line
pred_finf3x_find_c <- pred_finf3x_find_c%>%
  unnest()%>%
  ungroup()%>%
  select(line, iter, gen, asy_d, c_rate, tmin2)%>%distinct()
```
After fitting the curves, we want to look at how copepod survival and infectivity to fish change as a function of time spent in copepods.

```{r}
pred_copx <- left_join(pred_cinf2x, pred_surv2x, by = c("gen", "line", "iter"))%>%
  left_join(., pred_finf3x_find_c, by = c("gen", "line", "iter"))%>%
  filter(gen == 4)%>%
  select(-cop_block, -pred, -trait)
```

```{r}
# make data frame with means/model params and time in copepods
day_cop <- seq(0, 25, by = 0.2) # days in copepod
fitness_cop <- data.frame(days_cop = rep(day_cop, 3),
                          line = rep(c("control", "fast", "slow"), each = length(day_cop))
)

fitness_cop <- left_join(pred_copx, fitness_cop)
```

```{r}
# make composite vars
fitness_cop <- fitness_cop%>%
  mutate(cop_surv = exp(mort_rate * days_cop),
         fish_infectivity = if_else(days_cop < tmin2, 
                                    0,
                                    asy_d * (1 - exp(-c_rate*(days_cop - tmin2))))
         )%>%
  mutate(prob_survival_to_time_point = cop_inf * cop_surv,
         prob_to_inf_fish = cop_inf * cop_surv * fish_infectivity)
```

```{r}
# for each variable, take median, upper and lower CI at each day
med_upr_lwr <- list(
  fit = ~median(.x, na.rm = TRUE),
  lwr = ~quantile(.x, probs = 0.025, na.rm=T),
  upr = ~quantile(.x, probs = 0.975, na.rm=T)
)

fitness_cop_avg <- fitness_cop%>%
  group_by(line, days_cop)%>%
  summarise(across( 
    c(cop_inf, mort_rate, asy_d, c_rate, tmin2, 
      cop_surv, prob_survival_to_time_point,
      fish_infectivity, prob_to_inf_fish),
    med_upr_lwr,
    .names = "{.fn}.{.col}")
    )%>%
  ungroup()

fitness_cop_avg <- fitness_cop_avg%>%
  mutate(line = fct_relevel(line, c("fast", "control", "slow")))
```

Here is the predicted survival in copepods. The solid line is the best estimate, the dashed and dotted lines are the upper and lower 95% CIs, respectively. The dots are the mean estimates from the final generation. Copepod survival did not differ among lines.

```{r}
ggplot(fitness_cop_avg, 
       aes(x = days_cop,
           y = fit.cop_surv,
           color = line)) +
  geom_line(aes(y = lwr.cop_surv), linetype = "dotted") +
  geom_line(aes(y = upr.cop_surv), linetype = "dashed") +
  geom_line(size = 1) +
  geom_point(data = pred_surv2%>%filter(gen == 4), aes(y = 1-fit, x = 13)) +
  # scale_y_continuous(limits = c(0,1)) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  # facet_wrap(~line) +
  labs(x = "Days in copepod",
       y = "Survival probability")
```

We can also take into account the fact that not every coracidia will infect a copepod. Here is the probability that parasites first infect and then survive in copepods. The fast line had slightly lower infection rates, but this was not a general trend.

```{r}
f_sya <- ggplot(fitness_cop_avg, 
       aes(x = days_cop,
           y = fit.prob_survival_to_time_point,
           color = line)) +
  geom_line(aes(y = lwr.prob_survival_to_time_point), linetype = "dotted") +
  geom_line(aes(y = upr.prob_survival_to_time_point), linetype = "dashed") +
  geom_line(size = 1) +
  geom_point(data = pred_cinf2%>%filter(gen == 4), aes(y = fit, x = 0)) +
  geom_point(data = pred_surv2%>%filter(gen == 4), 
             aes(y = (1-fit) * pred_cinf2%>%filter(gen == 4)%>%.$fit,
                 x = 13)) +
  # scale_y_continuous(limits = c(0,1)) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  labs(x = "Days in copepod",
       y = "Survival probability") 
f_sya
```

Here are the asymptotic curves fit to the fish infection rates in the final generation. The fast line had earlier infectivity and a higher asymptote, but there are wide CIs around these trends.

```{r}
f_syb <- ggplot(fitness_cop_avg, 
       aes(x = days_cop,
           y = fit.fish_infectivity,
           color = line)) +
  geom_line(aes(y = lwr.fish_infectivity), linetype = "dotted") +
  geom_line(aes(y = upr.fish_infectivity), linetype = "dashed") +
  geom_line(size = 1) +
  geom_point(data = pred_finf3%>%filter(gen == 4), aes(y = fit, x = fish_exp_on_cop_dpe)) +
  # scale_y_continuous(limits = c(0,1)) +
  scale_x_continuous(limits = c(9,21)) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  labs(x = "Days in copepod",
       y = "Infection rate in fish") 
f_syb
```

We can multiply survival probability by fish infectivity to obtain the probability that a parasite will successfully infect fish (assuming a constant consumption rate by fish). The probability increases before slowing decreasing as copepod die off.

```{r}
f_syc <- ggplot(fitness_cop_avg, 
       aes(x = days_cop,
           y = fit.prob_to_inf_fish,
           color = line)) +
  geom_line(aes(y = lwr.prob_to_inf_fish), linetype = "dotted") +
  geom_line(aes(y = upr.prob_to_inf_fish), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  scale_x_continuous(limits = c(9,25)) +
  labs(x = "Days in copepod",
       y = "Probability to infect fish")
f_syc
```

## Probability of surviving until breeding and expected egg production

After infecting fish, parasites must survive, grow, and be transmitted to birds. Fish mortality rates we can take from the experiment. We can also extract fish growth curves for each selection line (plerocercoid size vs age of dissection). Then, we can use plerocercoid size to predict fecundity.

```{r}
# fish survival model
post_sol2 <- m2_fsurv75$Sol/sqrt(1 + c2 * m2_fsurv75$VCV[, 'units']) # correction suggested in course notes
pdx <- m2_fsurv75$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/1 # number of data points per trait
p_i <- which(dat_fsurv2_75dpi$pred %in% c("yes5")) # points where we want predicted vals and cred int
pdx <- pdx[c(p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/1 # number of points for each trait we want to predict
num_fe <- m2_fsurv75$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(post_sol2[,1:num_fe]) # predicteds via matrix mult 

# predicted means for every iteration for every trait
px <- data.frame(pred_here5%>%select(-fish_exp_on_cop_dpe)%>%distinct(),
                 finf_p = boot::inv.logit(p_all[1:p_n,]))

# reshape predicted vals for all iter, calc fit and quantiles
pred_fsurv2x <- px%>%
  pivot_longer(
    cols = finf_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "fsurv"
  )

pred_fsurv2x <- pred_fsurv2x%>%
  mutate(mort_rate = log(1-fsurv)/74)
```
```{r}
# these are model parameters needed to calculate growth curves
px <- m2_pler_log$Sol[,c("(Intercept)", "age_diss_cen", "gen_line4_control", "gen_line4_fast", "gen_line4_slow")]
pred_pler2x <- data.frame(px)
pred_pler2x <- mutate(pred_pler2x, iter = as.character(1:nrow(px)))%>%
  rename(pler_int = X.Intercept.)
```
```{r}
# these are model parameters needed to calculate fecundity from parasite size
px <- m2_bred_log2_ww$Sol[,c("(Intercept)", "log_ww_cen", "line_poolcontrol", "line_poolselected")]
pred_bred2x <- data.frame(px)
pred_bred2x <- mutate(pred_bred2x, iter = as.character(1:nrow(px)))%>%
  rename(egg_int = X.Intercept.)
```
```{r}
# combine posterior samples of parameters
pred_fishx <- left_join(pred_fsurv2x, pred_pler2x, by = "iter")%>%
  left_join(., pred_bred2x, by = "iter")%>%
  filter(gen == 4)%>%
  select(-cop_block, -pred, -trait, -tank_id)
```


```{r}
# incorporate days post infection into dataset
day_fish <- seq(0, 90, by = 0.5)
fitness_fish <- data.frame(days_fish = rep(day_fish, 3),
                          line = rep(c("control", "fast", "slow"), each = length(day_fish))
)

fitness_fish <- left_join(pred_fishx, fitness_fish)
```

```{r}
# make composite vars 
fitness_fish <- fitness_fish%>%
  mutate(fish_surv = exp(mort_rate * days_fish),
         pler_size = case_when(
           line == "control" ~ 
             exp(pler_int + age_diss_cen * (days_fish - med_age_diss) + gen_line4_control),
           line == "fast" ~ 
             exp(pler_int + age_diss_cen * (days_fish - med_age_diss) + gen_line4_fast),
           line == "slow" ~ 
             exp(pler_int + age_diss_cen * (days_fish - med_age_diss) + gen_line4_slow)
           ))%>%
  mutate(eggs = case_when(
           line == "control" ~ 
             exp(egg_int + log_ww_cen * (log(pler_size) - log(mean(dat_bred$worm_bm_mg, na.rm = T))) +
                   line_poolcontrol),
           line == "fast" ~ 
             exp(egg_int + log_ww_cen * (log(pler_size) - log(mean(dat_bred$worm_bm_mg, na.rm = T))) +
                   line_poolselected),
           line == "slow" ~ 
             exp(egg_int + log_ww_cen * (log(pler_size) - log(mean(dat_bred$worm_bm_mg, na.rm = T))) +
                   line_poolselected)
           ),
         bird_inf_rate = if_else(pler_size < 50, 0, 0.7) # zero infectivity prior to 50 mg
         )%>%
  mutate(expected_eggs = fish_surv * bird_inf_rate * eggs)
```
```{r}
# for each variable, take median, upper and lower CI at each day
fitness_fish_avg <- fitness_fish%>%
  group_by(line, days_fish)%>%
  summarise(across( 
    c(fish_surv, pler_size, eggs, bird_inf_rate, expected_eggs),
    med_upr_lwr,
    .names = "{.fn}.{.col}")
    )%>%
  ungroup()

fitness_fish_avg <- fitness_fish_avg%>%
  mutate(line = fct_relevel(line, c("fast", "control", "slow")))
```

Here is the predicted survival of fish; it does not differ among the lines. The dots represent the mean estimates from the final generation.

```{r}
f_syd <- ggplot(fitness_fish_avg, 
       aes(x = days_fish,
           y = fit.fish_surv,
           color = line)) +
  geom_line(aes(y = lwr.fish_surv), linetype = "dotted") +
  geom_line(aes(y = upr.fish_surv), linetype = "dashed") +
  geom_line(size = 1) +
  geom_point(data = pred_fsurv2%>%filter(gen == 4), aes(y = 1-fit, x = 74)) +
  # scale_y_continuous(limits = c(0,1)) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  # facet_wrap(~line) +
  labs(x = "Days in fish",
       y = "Survival probability")
f_syd
```

Here is the estimated parasite growth in fish; again it is similar among groups. The horizontal line represents the estimated threshold size needed to infect birds (50 mg). This threshold is crossed in just under 50 days, which fits other experiments well. Note that, with long observations, we would need to fit a growth curve that levels off, i.e. mass does not keep accumulating exponentially.

```{r}
f_sye <- ggplot(fitness_fish_avg, 
       aes(x = days_fish,
           y = fit.pler_size,
           color = line)) +
  geom_hline(yintercept = 50, linetype = "dashed") +
  geom_line(aes(y = lwr.pler_size), linetype = "dotted") +
  geom_line(aes(y = upr.pler_size), linetype = "dashed") +
  geom_line(size = 1) +
  geom_point(data = pred_pler2_log%>%filter(gen == 4), aes(y = fit, x = med_age_diss)) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  labs(x = "Days in fish",
       y = "Plerocercoid mass (mg)")
f_sye
```

The increase in fecundity follows basically the same trajectory (actually, it should be a bit steeper, since fecundity increase with body size more than proportionally). The control line produced more eggs than the selected lines.

```{r}
ggplot(fitness_fish_avg, 
       aes(x = days_fish,
           y = fit.eggs,
           color = line)) +
  geom_line(aes(y = lwr.eggs), linetype = "dotted") +
  geom_line(aes(y = upr.eggs), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  labs(x = "Days in fish",
       y = "Eggs")
```

However, only worms that survive transmission to birds will produce eggs. When we include this, then there is a threshold pattern; below 50 mg worms die upon tranmission to birds, but above 50 mg, then produce eggs relative to their body size.

```{r}
f_syf <- ggplot(fitness_fish_avg, 
       aes(x = days_fish,
           y = fit.expected_eggs/1000,
           color = line)) +
  geom_line(aes(y = lwr.expected_eggs/1000), linetype = "dotted") +
  geom_line(aes(y = upr.expected_eggs/1000), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  coord_cartesian(xlim = c(30, 90)) +
  labs(x = "Days in fish",
       y = "Eggs (thousands)")
f_syf + guides(color="none")
```


```{r}
f_sy <- cowplot::plot_grid(
  f_sya + guides(color="none"),
  f_syb + guides(color="none"),
  f_syc + guides(color="none"),
  f_syd + guides(color="none"),
  f_sye + 
    theme(legend.title = element_blank(),
          legend.background = element_rect(color = "black"),
          legend.position = c(0.025, 0.975),
          legend.justification = c(0, 1)),
  f_syf + guides(color="none"),
  nrow = 2,
  align = "hv",
  labels = "AUTO")
ggsave(f_sy, filename = "../figs/figSX_fitness_components.png", width = 75*3, height = 75*2, units = "mm")
```

## Fitness calculations

Now, let's combine the calculations from the two hosts. Fitness is a function of time spent in both hosts (i.e. time in copepods determines infectivity, whereas time in fish determines fecundity). Therefore, we can make a contour plot with fitness on the z-axis as a function of time in the two hosts.

```{r}
fitness_all <- left_join(ungroup(fitness_cop_avg)%>%
                           select(line, days_cop, fit.prob_to_inf_fish),
                         ungroup(fitness_fish_avg)%>%
                           select(line, days_fish, fit.expected_eggs),
                         by = c("line"))

fitness_all <- fitness_all%>%
  mutate(expected_eggs_dX = fit.prob_to_inf_fish * fit.expected_eggs,
         relative_fitness = 1)

fitness_all$relative_fitness[which(fitness_all$line == "fast")] <- 
  fitness_all%>%
  filter(line=="fast")%>%.$expected_eggs_dX /
  fitness_all%>%
  filter(line=="control")%>%.$expected_eggs_dX

fitness_all$relative_fitness[which(fitness_all$line == "slow")] <- 
  fitness_all%>%
  filter(line=="slow")%>%.$expected_eggs_dX /
  fitness_all%>%
  filter(line=="control")%>%.$expected_eggs_dX
```

Fitness (removing non-zero values) tends to be highest when spending little time in copepods and more time in fish.

```{r}
ggplot(fitness_all%>%filter(expected_eggs_dX>0),
       aes(x=days_cop, y=days_fish, z=expected_eggs_dX)) +
  geom_contour_filled() +
  facet_wrap(~line) +
  scale_fill_brewer(palette = "RdBu", direction = -1) +
  labs(x = "days in copepods", y = "days in sticklebacks", fill = "eggs")
```
The maximum fitness tends to be around 16 days in copepods and longer in fish (i.e. fecundity increases faster than fish mortality).

```{r}
fitness_all%>%
  filter(line == "fast")%>%
  arrange(desc(expected_eggs_dX))%>%
  slice_head(n=5)
```

Absolute fitness impacts population growth but understanding genotype spread can be better evaluated with relative fitness. Here is the relative fitness of parasites in the fast and slow lines. Relative fitness is maximized at earlier transmission times. Still, over large parts of the parameter space, there is not a big advantage to fast development.

```{r}
ggplot(fitness_all%>%filter(line != "control", expected_eggs_dX > 0),
       aes(x=days_cop, y=days_fish, z=relative_fitness)) +
  geom_contour_filled() +
  facet_wrap(~line) +
  scale_fill_brewer(palette = "RdBu", direction = -1) +
  scale_y_log10() + scale_x_log10() +
  labs(x = "days in copepods", y = "days in sticklebacks", fill = "Rel. fitness")
```

```{r}
# fitness_all%>%
#   filter(line == "fast", !is.infinite(relative_fitness))%>%
#   arrange(desc(relative_fitness))%>%
#   slice_head(n=5)
```

These contour plots do not show the confidence in the fitness calculations. Therefore, it may be preferable to calculate fitness holding time in one host constant, i.e. take a vertical cross section of the contour plot. We consider four cross-sections from the contour plots above, short time in copepods, long time in copepods, short time in fish, long time in fish. Let's start by calculating the expected eggs for different times spent in copepods, assuming that worms then reproduce after 90 days in fish (i.e. bird predation is low - worms will be big).

```{r}
fitness_cop2 <- left_join(ungroup(fitness_cop), 
                         fitness_fish%>%
                           filter(days_fish == 90)%>%
                           select(iter, gen, line, expected_eggs),
                         by = c("gen", "line", "iter")
                         )

fitness_cop2 <- fitness_cop2%>%
  mutate(expected_eggs_dX = prob_to_inf_fish * expected_eggs,
         relative_fitness = 1)
mx <- fitness_cop2%>%filter(expected_eggs_dX>0)%>%.$expected_eggs_dX%>%min()

fitness_cop2$relative_fitness[which(fitness_cop2$line == "fast")] <- 
  (fitness_cop2%>%
  filter(line=="fast")%>%.$expected_eggs_dX+mx) /
  (fitness_cop2%>%
  filter(line=="control")%>%.$expected_eggs_dX+mx)

fitness_cop2$relative_fitness[which(fitness_cop2$line == "slow")] <- 
  (fitness_cop2%>%
  filter(line=="slow")%>%.$expected_eggs_dX+mx) /
  (fitness_cop2%>%
  filter(line=="control")%>%.$expected_eggs_dX+mx)

# for each variable, take median, upper and lower CI at each day
fitness_cop_avg2 <- fitness_cop2%>%
  group_by(line, days_cop)%>%
  summarise(across( 
    c(cop_inf, prob_survival_to_time_point,
      fish_infectivity, prob_to_inf_fish, expected_eggs_dX, relative_fitness),
    med_upr_lwr,
    .names = "{.fn}.{.col}")
    )%>%
  ungroup()

fitness_cop_avg2 <- fitness_cop_avg2%>%
  mutate(line = fct_relevel(line, c("fast", "control", "slow")))
```

Although the fast line had higher infectivity than controls, the controls had higher fecundity. These seem to cancel each other out. Slow genotypes have lower fitness than fast ones.

```{r}
f_sza <- ggplot(fitness_cop_avg2, 
       aes(x = days_cop,
           y = fit.expected_eggs_dX/1000,
           color = line)) +
  geom_line(aes(y = lwr.expected_eggs_dX/1000), linetype = "dotted") +
  geom_line(aes(y = upr.expected_eggs_dX/1000), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_x_continuous(limits = c(9, 20)) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  labs(x = "Days in copepods",
       y = "Eggs (thousands)\nreproduction 90 dpi in fish") +
  theme(legend.title = element_blank(),
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0, 1))
f_sza
```

The largest difference in relative fitness is at early time points. And it is skewed - the slow developers have a bigger disadvantage than the advantage of the fast developers. Later on, there is little benefit to fast development.

```{r}
f_szb <- ggplot(fitness_cop_avg2, 
       aes(x = days_cop,
           y = fit.relative_fitness,
           color = line)) +
  geom_line(aes(y = lwr.relative_fitness), linetype = "dotted") +
  geom_line(aes(y = upr.relative_fitness), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_x_continuous(limits = c(9, 20)) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  scale_y_log10() +
  # scale_y_continuous(limits = c(0, 3.5)) +
  labs(x = "Days in copepods",
       y = "Relative fitness\nreproduction 90 dpi in fish") +
  theme(legend.title = element_blank(),
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0, 1)) +
  coord_cartesian(ylim = c(0.2, 5))
f_szb
```
Here is the relative advantage (%) of the fast line in the above plot.

```{r}
fitness_cop_avg2%>%
  filter(fit.relative_fitness != 1, line == "fast")%>%
  mutate(rf = fit.relative_fitness-1)%>%
  .$rf%>%
  summary()
```
Here is the relative disadvantage (%) of the slow line in the above plot.

```{r}
fitness_cop_avg2%>%
  filter(fit.relative_fitness != 1, line == "slow")%>%
  mutate(rf = 1-fit.relative_fitness)%>%
  .$rf%>%
  summary()
```

Now, let's make the same two plots, but assume that fish experience higher bird predation, i.e. transmission to birds occurs earlier at 60 dpi.

```{r}
fitness_cop3 <- left_join(ungroup(fitness_cop), 
                         fitness_fish%>%
                           filter(days_fish == 60)%>%
                           select(iter, gen, line, expected_eggs),
                         by = c("gen", "line", "iter")
                         )

fitness_cop3 <- fitness_cop3%>%
  mutate(expected_eggs_dX = prob_to_inf_fish * expected_eggs,
         relative_fitness = 1)
mx <- fitness_cop3%>%filter(expected_eggs_dX>0)%>%.$expected_eggs_dX%>%min()

fitness_cop3$relative_fitness[which(fitness_cop3$line == "fast")] <- 
  (fitness_cop3%>%
  filter(line=="fast")%>%.$expected_eggs_dX+mx) /
  (fitness_cop3%>%
  filter(line=="control")%>%.$expected_eggs_dX+mx)

fitness_cop3$relative_fitness[which(fitness_cop3$line == "slow")] <- 
  (fitness_cop3%>%
  filter(line=="slow")%>%.$expected_eggs_dX+mx) /
  (fitness_cop3%>%
  filter(line=="control")%>%.$expected_eggs_dX+mx)

# for each variable, take median, upper and lower CI at each day
fitness_cop_avg3 <- fitness_cop3%>%
  group_by(line, days_cop)%>%
  summarise(across( 
    c(cop_inf, prob_survival_to_time_point,
      fish_infectivity, prob_to_inf_fish, expected_eggs_dX, relative_fitness),
    med_upr_lwr,
    .names = "{.fn}.{.col}")
    )%>%
  ungroup()

fitness_cop_avg3 <- fitness_cop_avg3%>%
  mutate(line = fct_relevel(line, c("fast", "control", "slow")))
```

The pattern is similar, though overall egg production is lower.

```{r}
f_szc <- ggplot(fitness_cop_avg3, 
       aes(x = days_cop,
           y = fit.expected_eggs_dX/1000,
           color = line)) +
  geom_line(aes(y = lwr.expected_eggs_dX/1000), linetype = "dotted") +
  geom_line(aes(y = upr.expected_eggs_dX/1000), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_x_continuous(limits = c(9, 20)) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  labs(x = "Days in copepods",
       y = "Eggs (thousands)\nreproduction 60 dpi in fish") +
  theme(legend.title = element_blank(),
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0, 1))
f_szc
```

The pattern in relative fitness is also about the same. 

```{r}
f_szd <- ggplot(fitness_cop_avg3, 
       aes(x = days_cop,
           y = fit.relative_fitness,
           color = line)) +
  geom_line(aes(y = lwr.relative_fitness), linetype = "dotted") +
  geom_line(aes(y = upr.relative_fitness), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_x_continuous(limits = c(9, 20)) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  scale_y_log10() +
  # scale_y_continuous(limits = c(0, 3)) +
  labs(x = "Days in copepods",
       y = "Relative fitness\nreproduction 60 dpi in fish") +
  theme(legend.title = element_blank(),
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0, 1)) +
  coord_cartesian(ylim = c(0.2, 5))
f_szd
```

Here is the relative advantage (%) of the fast line in the above plot.

```{r}
fitness_cop_avg3%>%
  filter(fit.relative_fitness != 1, line == "fast")%>%
  mutate(rf = fit.relative_fitness-1)%>%
  .$rf%>%
  summary()
```
Here is the relative disadvantage (%) of the slow line in the above plot.

```{r}
fitness_cop_avg3%>%
  filter(fit.relative_fitness != 1, line == "slow")%>%
  mutate(rf = 1-fit.relative_fitness)%>%
  .$rf%>%
  summary()
```

Now, we focus on the other host. Let's compare the lines when transmitted to fish at 12 dpi in copepods. This early transmission time is when the differences between lines should be largest.

```{r}
fitness_fish2 <- left_join(ungroup(fitness_fish), 
                         fitness_cop%>%
                           ungroup()%>%
                           filter(days_cop == 12)%>%
                           select(iter, gen, line, prob_to_inf_fish),
                         by = c("gen", "line", "iter")
                         )

fitness_fish2 <- fitness_fish2%>%
  mutate(expected_eggs_dX = prob_to_inf_fish * expected_eggs,
         relative_fitness = 1)
mx <- fitness_fish2%>%filter(expected_eggs_dX>0)%>%.$expected_eggs_dX%>%min()

fitness_fish2$relative_fitness[which(fitness_fish2$line == "fast")] <- 
  (fitness_fish2%>%
  filter(line=="fast")%>%.$expected_eggs_dX+mx) /
  (fitness_fish2%>%
  filter(line=="control")%>%.$expected_eggs_dX+mx)

fitness_fish2$relative_fitness[which(fitness_fish2$line == "slow")] <- 
  (fitness_fish2%>%
  filter(line=="slow")%>%.$expected_eggs_dX+mx) /
  (fitness_fish2%>%
  filter(line=="control")%>%.$expected_eggs_dX+mx)

# for each variable, take median, upper and lower CI at each day
fitness_fish_avg2 <- fitness_fish2%>%
  group_by(line, days_fish)%>%
  summarise(across( 
    c(fish_surv, pler_size, eggs, bird_inf_rate, expected_eggs_dX, relative_fitness),
    med_upr_lwr,
    .names = "{.fn}.{.col}")
    )%>%
  ungroup()

fitness_fish_avg2 <- fitness_fish_avg2%>%
  mutate(line = fct_relevel(line, c("fast", "control", "slow")))
```

Indeed, the fast line has the highest fecundity here, but only slightly higher than the controls. The slow line, though, has much lower fecundity.

```{r}
f_szza <- ggplot(fitness_fish_avg2, 
       aes(x = days_fish,
           y = fit.expected_eggs_dX/1000,
           color = line)) +
  geom_line(aes(y = lwr.expected_eggs_dX/1000), linetype = "dotted") +
  geom_line(aes(y = upr.expected_eggs_dX/1000), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_x_continuous(limits = c(35, 90)) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  labs(x = "Days in sticklebacks",
       y = "Eggs (thousands)\ntransmitted from copepods 12 dpi") +
  theme(legend.title = element_blank(),
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0, 1))
f_szza
```

The plot of relative fitness also shows that the difference among groups is largest early on, because there is a big difference between some reproduction and no reproduction.

```{r}
f_szzb <- ggplot(fitness_fish_avg2, 
       aes(x = days_fish,
           y = fit.relative_fitness,
           color = line)) +
  geom_line(aes(y = lwr.relative_fitness), linetype = "dotted") +
  geom_line(aes(y = upr.relative_fitness), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_x_continuous(limits = c(35, 90)) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  scale_y_log10() +
  # scale_y_continuous(limits = c(0, 3.5)) +
  labs(x = "Days in sticklebacks",
       y = "Relative fitness\ntransmitted from copepods 12 dpi") +
  theme(legend.title = element_blank(),
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0, 1)) +
  coord_cartesian(ylim = c(0.2, 5))
f_szzb
```

Here is the relative advantage (%) of the fast line in the above plot.

```{r}
fitness_fish_avg2%>%
  filter(fit.relative_fitness != 1, line == "fast")%>%
  mutate(rf = fit.relative_fitness-1)%>%
  .$rf%>%
  summary()
```
Here is the relative disadvantage (%) of the slow line in the above plot.

```{r}
fitness_fish_avg2%>%
  filter(fit.relative_fitness != 1, line == "slow")%>%
  mutate(rf = 1-fit.relative_fitness)%>%
  .$rf%>%
  summary()
```

Finally, let's assume that fish predation is weaker and thus that parasites spend more time in copepods before transmisson. Let's look at expected egg output if parasites spend 16 days in copepods.

```{r}
fitness_fish3 <- left_join(ungroup(fitness_fish), 
                         fitness_cop%>%
                           ungroup()%>%
                           filter(days_cop == 16)%>%
                           select(iter, gen, line, prob_to_inf_fish),
                         by = c("gen", "line", "iter")
                         )

fitness_fish3 <- fitness_fish3%>%
  mutate(expected_eggs_dX = prob_to_inf_fish * expected_eggs,
         relative_fitness = 1)
mx <- fitness_fish3%>%filter(expected_eggs_dX>0)%>%.$expected_eggs_dX%>%min()

fitness_fish3$relative_fitness[which(fitness_fish3$line == "fast")] <- 
  (fitness_fish3%>%
  filter(line=="fast")%>%.$expected_eggs_dX+mx) /
  (fitness_fish3%>%
  filter(line=="control")%>%.$expected_eggs_dX+mx)

fitness_fish3$relative_fitness[which(fitness_fish3$line == "slow")] <- 
  (fitness_fish3%>%
  filter(line=="slow")%>%.$expected_eggs_dX+mx) /
  (fitness_fish3%>%
  filter(line=="control")%>%.$expected_eggs_dX+mx)

# for each variable, take median, upper and lower CI at each day
fitness_fish_avg3 <- fitness_fish3%>%
  group_by(line, days_fish)%>%
  summarise(across( 
    c(fish_surv, pler_size, eggs, bird_inf_rate, expected_eggs_dX, relative_fitness),
    med_upr_lwr,
    .names = "{.fn}.{.col}")
    )%>%
  ungroup()

fitness_fish_avg3 <- fitness_fish_avg3%>%
  mutate(line = fct_relevel(line, c("fast", "control", "slow")))
```

The difference between selection lines is smaller because the fast line no longer enjoys the advantage of earlier transmission.

```{r}
f_szzc <- ggplot(fitness_fish_avg3, 
       aes(x = days_fish,
           y = fit.expected_eggs_dX/1000,
           color = line)) +
  geom_line(aes(y = lwr.expected_eggs_dX/1000), linetype = "dotted") +
  geom_line(aes(y = upr.expected_eggs_dX/1000), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_x_continuous(limits = c(35, 90)) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  labs(x = "Days in sticklebacks",
       y = "Eggs (thousands)\ntransmitted from copepods 16 dpi") +
  theme(legend.title = element_blank(),
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0, 1))
f_szzc
```

Accordingly, the differences in relative fitness are much smaller.

```{r}
f_szzd <- ggplot(fitness_fish_avg3, 
       aes(x = days_fish,
           y = fit.relative_fitness,
           color = line)) +
  geom_line(aes(y = lwr.relative_fitness), linetype = "dotted") +
  geom_line(aes(y = upr.relative_fitness), linetype = "dashed") +
  geom_line(size = 1) +
  scale_color_manual(values = c("red", "black", "blue")) +
  scale_x_continuous(limits = c(35, 90)) +
  scale_fill_manual(values = c("red", "black", "blue")) +
  scale_y_log10() +
  # scale_y_continuous(limits = c(0, 3.5)) +
  labs(x = "Days in sticklebacks",
       y = "Relative fitness\ntransmitted from copepods 16 dpi") +
  theme(legend.title = element_blank(),
        legend.background = element_rect(color = "black"),
        legend.position = c(0.025, 0.975),
        legend.justification = c(0, 1)) +
  coord_cartesian(ylim = c(0.2, 5))
f_szzd
```
Here is the relative advantage (%) of the fast line in the above plot.

```{r}
fitness_fish_avg3%>%
  filter(fit.relative_fitness != 1, line == "fast")%>%
  mutate(rf = fit.relative_fitness-1)%>%
  .$rf%>%
  summary()
```
Here is the relative disadvantage (%) of the slow line in the above plot.

```{r}
fitness_fish_avg3%>%
  filter(fit.relative_fitness != 1, line == "slow")%>%
  mutate(rf = 1-fit.relative_fitness)%>%
  .$rf%>%
  summary()
```

```{r}
f_sz <- cowplot::plot_grid(
  cowplot::plot_grid(f_szc + guides(color="none"), f_szd + guides(color="none")),
  cowplot::plot_grid(f_sza + guides(color="none"), f_szb + guides(color="none")),
  cowplot::plot_grid(f_szza + guides(color="none"), f_szzb + guides(color="none")),
  cowplot::plot_grid(f_szzc, f_szzd + guides(color="none")),
  nrow = 2,
  align = "hv",
  labels = "AUTO"
)

ggsave(f_sz, filename = "../figs/figSZ_fitness_lines.png", width = 75*3.5, height = 75*2, units = "mm")
```

One caveat to these fitness calculations is that they assume traits are uncorrelated. For instance, the posterior samples to calculate infection rate were independent of those used to calculate survival. But traits could be correlated (e.g. large plerocercoids, high fecundity), which would affect the CIs. Therefore, it is worth attempting to fit multivariate models.

# Conclusions

We selected tapeworms for faster and slower development in copepods. We observed a significant response to selection. Moreover, by the final generation, worms were able to infect fish earlier in the fast line. Correlated responses included more developmental defects in procercoids in the slow line and lower fecundity in the selected lines. The reduced fecundity offsets the gains in infectivity in the fast line

```{r}
save.image(file = "02testing_selection_response.RData")
```

```{r}
sessionInfo()
```

